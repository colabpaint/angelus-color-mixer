<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Angelus Paint Color Mixer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            background: linear-gradient(90deg, #e94560, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 30px;
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .image-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 20px;
            border: 2px dashed rgba(255, 255, 255, 0.2);
            transition: border-color 0.3s;
        }

        .image-section:hover {
            border-color: rgba(233, 69, 96, 0.5);
        }

        .image-section.dragover {
            border-color: #e94560;
            background: rgba(233, 69, 96, 0.1);
        }

        .drop-zone {
            min-height: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .drop-zone-text {
            text-align: center;
            color: #888;
        }

        .drop-zone-text h3 {
            margin-bottom: 10px;
            font-size: 1.3em;
        }

        .drop-zone-text p {
            font-size: 0.9em;
        }

        #imageCanvas {
            max-width: 100%;
            cursor: crosshair;
            border-radius: 8px;
            display: none;
        }

        .canvas-container {
            position: relative;
            overflow: hidden;
        }

        .zoom-controls {
            display: none;
            gap: 8px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .zoom-controls.visible {
            display: flex;
        }

        .zoom-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 8px 16px;
            color: #fff;
            cursor: pointer;
            font-size: 0.9em;
            transition: background 0.2s;
        }

        .zoom-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .zoom-info {
            color: #888;
            font-size: 0.85em;
            padding: 8px;
            display: flex;
            align-items: center;
        }

        .color-preview-float {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 3px solid white;
            border-radius: 50%;
            pointer-events: none;
            display: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transform: translate(-50%, -120%);
        }

        .results-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .card h3 {
            margin-bottom: 15px;
            font-size: 1.1em;
            color: #e94560;
        }

        .color-input-section {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .color-display {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .color-swatch {
            width: 80px;
            height: 80px;
            border-radius: 12px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .color-info {
            flex: 1;
        }

        .color-hex {
            font-size: 1.5em;
            font-weight: bold;
            font-family: monospace;
        }

        .color-rgb {
            color: #888;
            font-size: 0.9em;
            margin-top: 5px;
        }

        input[type="text"] {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 12px 16px;
            color: #fff;
            font-size: 1em;
            font-family: monospace;
            width: 140px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #e94560;
        }

        input[type="color"] {
            width: 50px;
            height: 46px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: transparent;
        }

        button {
            background: linear-gradient(135deg, #e94560, #ff6b6b);
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            color: white;
            font-size: 1em;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
        }

        .chart-container {
            position: relative;
            height: 250px;
            margin: 20px 0;
        }

        .ratio-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .ratio-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .ratio-color {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .ratio-name {
            flex: 1;
            font-size: 0.9em;
        }

        .ratio-value {
            font-weight: bold;
            font-family: monospace;
            color: #e94560;
        }

        .result-preview {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
        }

        .result-swatch {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .error-badge {
            display: inline-block;
            padding: 4px 12px;
            background: rgba(233, 69, 96, 0.2);
            border-radius: 20px;
            font-size: 0.85em;
            color: #ff6b6b;
        }

        .hidden {
            display: none !important;
        }

        .instructions {
            background: rgba(233, 69, 96, 0.1);
            border-left: 4px solid #e94560;
            padding: 15px;
            border-radius: 0 8px 8px 0;
            margin-bottom: 20px;
        }

        .instructions h4 {
            margin-bottom: 8px;
        }

        .instructions ul {
            margin-left: 20px;
            color: #aaa;
            font-size: 0.9em;
        }

        .instructions li {
            margin-bottom: 4px;
        }

        .reset-btn {
            background: rgba(255, 255, 255, 0.1);
            margin-top: 10px;
            width: 100%;
        }

        .reset-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            box-shadow: none;
        }

        /* ã‚¢ãƒ‰ãƒã‚¤ã‚¹è¡¨ç¤º */
        .advice-container {
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border-left: 4px solid #e94560;
        }

        .advice-container.hidden {
            display: none;
        }

        .advice-header {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 12px;
            color: #e94560;
        }

        .advice-item {
            margin-bottom: 12px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .advice-item:last-child {
            margin-bottom: 0;
        }

        .advice-message {
            font-weight: bold;
            margin-bottom: 4px;
        }

        .advice-suggestion {
            font-size: 0.9em;
            color: #aaa;
        }

        .advice-brightness .advice-message { color: #FFD700; }
        .advice-hue .advice-message { color: #87CEEB; }
        .advice-saturation .advice-message { color: #FF69B4; }
        .advice-general .advice-message { color: #FFA500; }

        .advice-success {
            color: #00C864;
            font-weight: bold;
            text-align: center;
            padding: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Angelus Paint Color Mixer</h1>
        <p class="subtitle">Angelusçµµã®å…·ã®é…åˆæ¯”ç‡ã‚’è‡ªå‹•è¨ˆç®—</p>

        <div class="main-content">
            <div class="image-section" id="dropZone">
                <div class="drop-zone" id="dropZoneContent">
                    <div class="drop-zone-text">
                        <h3>ç”»åƒã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã¾ãŸã¯ãƒšãƒ¼ã‚¹ãƒˆ</h3>
                        <p>ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™</p>
                        <p style="margin-top: 15px; color: #666;">Ctrl+V ã§ç”»åƒã‚’ãƒšãƒ¼ã‚¹ãƒˆå¯èƒ½</p>
                    </div>
                </div>
                <div class="canvas-container">
                    <canvas id="imageCanvas"></canvas>
                    <div class="color-preview-float" id="colorPreviewFloat"></div>
                </div>
                <div class="zoom-controls" id="zoomControls">
                    <button class="zoom-btn" id="zoomInBtn">+ æ‹¡å¤§</button>
                    <button class="zoom-btn" id="zoomOutBtn">- ç¸®å°</button>
                    <button class="zoom-btn" id="zoomResetBtn">ãƒªã‚»ãƒƒãƒˆ</button>
                    <span class="zoom-info" id="zoomInfo">100% | ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ ã€ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•</span>
                </div>
                <input type="file" id="fileInput" accept="image/*" style="display: none;">
                <button class="reset-btn hidden" id="resetBtn">åˆ¥ã®ç”»åƒã‚’é¸æŠ</button>
            </div>

            <div class="results-section">
                <div class="instructions">
                    <h4>ä½¿ã„æ–¹</h4>
                    <ul>
                        <li>ç”»åƒã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ã¾ãŸã¯ãƒšãƒ¼ã‚¹ãƒˆ</li>
                        <li>ç”»åƒä¸Šã§ã‚¯ãƒªãƒƒã‚¯ã—ã¦è‰²ã‚’é¸æŠ</li>
                        <li>ã¾ãŸã¯ä¸‹ã®HEXã‚³ãƒ¼ãƒ‰ã‚’ç›´æ¥å…¥åŠ›</li>
                    </ul>
                </div>

                <div class="card">
                    <h3>ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè‰²</h3>
                    <div class="color-input-section">
                        <input type="color" id="colorPicker" value="#FF8800">
                        <input type="text" id="hexInput" placeholder="#FF8800" value="#FF8800">
                        <button id="calculateBtn">è¨ˆç®—</button>
                    </div>
                    <div class="color-display" style="margin-top: 15px;">
                        <div class="color-swatch" id="targetSwatch" style="background: #FF8800;"></div>
                        <div class="color-info">
                            <div class="color-hex" id="targetHex">#FF8800</div>
                            <div class="color-rgb" id="targetRgb">RGB(255, 136, 0)</div>
                        </div>
                    </div>
                </div>

                <div class="card" id="resultsCard">
                    <h3>é…åˆæ¯”ç‡</h3>
                    <div class="chart-container">
                        <canvas id="ratioChart"></canvas>
                    </div>
                    <div class="ratio-list" id="ratioList">
                        <!-- å‹•çš„ã«ç”Ÿæˆ -->
                    </div>
                    <div class="result-preview">
                        <div class="result-swatch" id="resultSwatch"></div>
                        <div>
                            <div style="font-weight: bold;">å†ç¾è‰²</div>
                            <div class="color-hex" id="resultHex" style="font-size: 1.2em;"></div>
                            <span class="error-badge" id="errorBadge"></span>
                            <div style="font-size: 0.75em; color: #666; margin-top: 4px;">
                                Î”Eâ‰¦5: å„ªç§€ | Î”Eâ‰¦10: è‰¯å¥½
                            </div>
                        </div>
                    </div>
                    <div class="advice-container hidden" id="adviceContainer">
                        <!-- ã‚¢ãƒ‰ãƒã‚¤ã‚¹ãŒå‹•çš„ã«è¡¨ç¤ºã•ã‚Œã‚‹ -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // AngelusåŸºæœ¬è‰²ï¼ˆè»¸ã¨ãªã‚‹6è‰²ï¼‰
        const PRIMARY_COLORS = {
            "001-Black": [20, 20, 25],
            "005-White": [255, 255, 255],
            "040-Blue": [0, 90, 170],
            "050-Green": [0, 130, 70],
            "064-Red": [200, 35, 40],
            "075-Yellow": [255, 210, 0]
        };

        // è£œåŠ©è‰²
        const SECONDARY_COLORS = {
            "024-Orange": [255, 100, 30],
            "047-Purple": [100, 50, 120],
            "014-Brown": [90, 55, 40],
            "029-Tan": [210, 170, 130],
            "041-Light Blue": [80, 160, 210],
            "052-Midnight Green": [0, 75, 70],
            "060-Burgundy": [120, 30, 50],
            "080-Dark Grey": [80, 80, 85],
            "082-Light Grey": [180, 180, 185],
            "188-Pink": [240, 150, 170],
            "186-Hot Pink": [255, 80, 140]
        };

        // å…¨è‰²ã‚’çµåˆ
        const BASE_COLORS = {...PRIMARY_COLORS, ...SECONDARY_COLORS};

        const COLOR_NAMES_JP = {
            "001-Black": "ãƒ–ãƒ©ãƒƒã‚¯",
            "005-White": "ãƒ›ãƒ¯ã‚¤ãƒˆ",
            "040-Blue": "ãƒ–ãƒ«ãƒ¼",
            "050-Green": "ã‚°ãƒªãƒ¼ãƒ³",
            "064-Red": "ãƒ¬ãƒƒãƒ‰",
            "075-Yellow": "ã‚¤ã‚¨ãƒ­ãƒ¼",
            "024-Orange": "ã‚ªãƒ¬ãƒ³ã‚¸",
            "047-Purple": "ãƒ‘ãƒ¼ãƒ—ãƒ«",
            "014-Brown": "ãƒ–ãƒ©ã‚¦ãƒ³",
            "029-Tan": "ã‚¿ãƒ³",
            "041-Light Blue": "ãƒ©ã‚¤ãƒˆãƒ–ãƒ«ãƒ¼",
            "052-Midnight Green": "ãƒŸãƒƒãƒ‰ãƒŠã‚¤ãƒˆã‚°ãƒªãƒ¼ãƒ³",
            "060-Burgundy": "ãƒãƒ¼ã‚¬ãƒ³ãƒ‡ã‚£",
            "080-Dark Grey": "ãƒ€ãƒ¼ã‚¯ã‚°ãƒ¬ãƒ¼",
            "082-Light Grey": "ãƒ©ã‚¤ãƒˆã‚°ãƒ¬ãƒ¼",
            "188-Pink": "ãƒ”ãƒ³ã‚¯",
            "186-Hot Pink": "ãƒ›ãƒƒãƒˆãƒ”ãƒ³ã‚¯"
        };

        const CHART_COLORS = {
            "001-Black": "#141419",
            "005-White": "#EEEEEE",
            "040-Blue": "#005AAA",
            "050-Green": "#008246",
            "064-Red": "#C82328",
            "075-Yellow": "#FFD200",
            "024-Orange": "#FF641E",
            "047-Purple": "#643278",
            "014-Brown": "#5A3728",
            "029-Tan": "#D2AA82",
            "041-Light Blue": "#50A0D2",
            "052-Midnight Green": "#004B46",
            "060-Burgundy": "#781E32",
            "080-Dark Grey": "#505055",
            "082-Light Grey": "#B4B4B9",
            "188-Pink": "#F096AA",
            "186-Hot Pink": "#FF508C"
        };

        // DOMè¦ç´ 
        const dropZone = document.getElementById('dropZone');
        const dropZoneContent = document.getElementById('dropZoneContent');
        const fileInput = document.getElementById('fileInput');
        const canvas = document.getElementById('imageCanvas');
        const ctx = canvas.getContext('2d');
        const colorPreviewFloat = document.getElementById('colorPreviewFloat');
        const colorPicker = document.getElementById('colorPicker');
        const hexInput = document.getElementById('hexInput');
        const calculateBtn = document.getElementById('calculateBtn');
        const resetBtn = document.getElementById('resetBtn');
        const zoomControls = document.getElementById('zoomControls');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomResetBtn = document.getElementById('zoomResetBtn');
        const zoomInfo = document.getElementById('zoomInfo');

        let currentImage = null;
        let ratioChart = null;

        // ã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³ç”¨ã®çŠ¶æ…‹
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let lastOffsetX = 0;
        let lastOffsetY = 0;

        // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                loadImage(files[0]);
            }
        });

        // ã‚¯ãƒªãƒƒã‚¯ã§ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ
        dropZoneContent.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                loadImage(e.target.files[0]);
            }
        });

        // ãƒšãƒ¼ã‚¹ãƒˆå¯¾å¿œ
        document.addEventListener('paste', (e) => {
            const items = e.clipboardData.items;
            for (let item of items) {
                if (item.type.indexOf('image') !== -1) {
                    const blob = item.getAsFile();
                    loadImage(blob);
                    break;
                }
            }
        });

        // ç”»åƒèª­ã¿è¾¼ã¿
        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    currentImage = img;

                    // ã‚ºãƒ¼ãƒ çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                    scale = 1;
                    offsetX = 0;
                    offsetY = 0;

                    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºèª¿æ•´
                    const maxWidth = dropZone.clientWidth - 40;
                    const initialScale = Math.min(1, maxWidth / img.width);
                    canvas.width = img.width * initialScale;
                    canvas.height = img.height * initialScale;
                    canvas.dataset.initialScale = initialScale;

                    drawImage();

                    dropZoneContent.classList.add('hidden');
                    canvas.style.display = 'block';
                    zoomControls.classList.add('visible');
                    resetBtn.classList.remove('hidden');
                    updateZoomInfo();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // ç”»åƒæç”»ï¼ˆã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³å¯¾å¿œï¼‰
        function drawImage() {
            if (!currentImage) return;

            const initialScale = parseFloat(canvas.dataset.initialScale) || 1;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();

            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ä¸­å¿ƒã‚’åŸºæº–ã«ã‚¹ã‚±ãƒ¼ãƒ«
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            ctx.translate(centerX + offsetX, centerY + offsetY);
            ctx.scale(scale, scale);
            ctx.translate(-centerX, -centerY);

            ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
            ctx.restore();
        }

        // ã‚ºãƒ¼ãƒ æƒ…å ±æ›´æ–°
        function updateZoomInfo() {
            const percent = Math.round(scale * 100);
            zoomInfo.textContent = `${percent}% | ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ ã€ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•`;
        }

        // ã‚ºãƒ¼ãƒ ã‚¤ãƒ³
        zoomInBtn.addEventListener('click', () => {
            scale = Math.min(scale * 1.25, 10);
            drawImage();
            updateZoomInfo();
        });

        // ã‚ºãƒ¼ãƒ ã‚¢ã‚¦ãƒˆ
        zoomOutBtn.addEventListener('click', () => {
            scale = Math.max(scale / 1.25, 0.1);
            drawImage();
            updateZoomInfo();
        });

        // ã‚ºãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆ
        zoomResetBtn.addEventListener('click', () => {
            scale = 1;
            offsetX = 0;
            offsetY = 0;
            drawImage();
            updateZoomInfo();
        });

        // ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ 
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.max(0.1, Math.min(10, scale * delta));

            // ãƒã‚¦ã‚¹ä½ç½®ã‚’åŸºæº–ã«ã‚ºãƒ¼ãƒ 
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left - canvas.width / 2;
            const mouseY = e.clientY - rect.top - canvas.height / 2;

            offsetX = mouseX - (mouseX - offsetX) * (newScale / scale);
            offsetY = mouseY - (mouseY - offsetY) * (newScale / scale);

            scale = newScale;
            drawImage();
            updateZoomInfo();
        });

        // ãƒ‰ãƒ©ãƒƒã‚°ã§ãƒ‘ãƒ³
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 2 || e.shiftKey) { // å³ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯Shift+ã‚¯ãƒªãƒƒã‚¯ã§ãƒ‘ãƒ³
                isDragging = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                lastOffsetX = offsetX;
                lastOffsetY = offsetY;
                canvas.style.cursor = 'grabbing';
                e.preventDefault();
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                offsetX = lastOffsetX + (e.clientX - dragStartX);
                offsetY = lastOffsetY + (e.clientY - dragStartY);
                drawImage();
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                canvas.style.cursor = 'crosshair';
            }
        });

        // å³ã‚¯ãƒªãƒƒã‚¯ãƒ¡ãƒ‹ãƒ¥ãƒ¼ç„¡åŠ¹åŒ–
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¯ãƒªãƒƒã‚¯ã§è‰²å–å¾—
        canvas.addEventListener('click', (e) => {
            if (isDragging) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ãƒ”ã‚¯ã‚»ãƒ«ã‹ã‚‰ç›´æ¥è‰²ã‚’å–å¾—
            const pixel = ctx.getImageData(x, y, 1, 1).data;

            // é€æ˜éƒ¨åˆ†ï¼ˆç”»åƒå¤–ï¼‰ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã¯ç„¡è¦–
            if (pixel[3] === 0) return;

            const hex = rgbToHex(pixel[0], pixel[1], pixel[2]);

            updateTargetColor(hex);
            calculateMix();
        });

        // ãƒã‚¦ã‚¹ç§»å‹•ã§ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const pixel = ctx.getImageData(x, y, 1, 1).data;

            // é€æ˜éƒ¨åˆ†ã¯è¡¨ç¤ºã—ãªã„
            if (pixel[3] === 0) {
                colorPreviewFloat.style.display = 'none';
                return;
            }

            const hex = rgbToHex(pixel[0], pixel[1], pixel[2]);

            colorPreviewFloat.style.display = 'block';
            colorPreviewFloat.style.left = x + 'px';
            colorPreviewFloat.style.top = y + 'px';
            colorPreviewFloat.style.backgroundColor = hex;
        });

        canvas.addEventListener('mouseleave', () => {
            colorPreviewFloat.style.display = 'none';
        });

        // ãƒªã‚»ãƒƒãƒˆ
        resetBtn.addEventListener('click', () => {
            currentImage = null;
            scale = 1;
            offsetX = 0;
            offsetY = 0;
            canvas.style.display = 'none';
            zoomControls.classList.remove('visible');
            dropZoneContent.classList.remove('hidden');
            resetBtn.classList.add('hidden');
            fileInput.value = '';
        });

        // è‰²å…¥åŠ›
        colorPicker.addEventListener('input', (e) => {
            updateTargetColor(e.target.value);
        });

        colorPicker.addEventListener('change', () => {
            calculateMix();
        });

        hexInput.addEventListener('input', (e) => {
            let value = e.target.value;
            if (value.match(/^#?[0-9A-Fa-f]{6}$/)) {
                if (!value.startsWith('#')) value = '#' + value;
                updateTargetColor(value);
            }
        });

        hexInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                calculateMix();
            }
        });

        calculateBtn.addEventListener('click', calculateMix);

        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè‰²æ›´æ–°
        function updateTargetColor(hex) {
            colorPicker.value = hex;
            hexInput.value = hex.toUpperCase();
            document.getElementById('targetSwatch').style.backgroundColor = hex;
            document.getElementById('targetHex').textContent = hex.toUpperCase();

            const rgb = hexToRgb(hex);
            document.getElementById('targetRgb').textContent = `RGB(${rgb.r}, ${rgb.g}, ${rgb.b})`;
        }

        // è‰²å¤‰æ›ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('').toUpperCase();
        }

        function hexToRgb(hex) {
            hex = hex.replace('#', '');
            return {
                r: parseInt(hex.substr(0, 2), 16),
                g: parseInt(hex.substr(2, 2), 16),
                b: parseInt(hex.substr(4, 2), 16)
            };
        }

        // RGB to Labå¤‰æ›ï¼ˆäººé–“ã®çŸ¥è¦šã«è¿‘ã„è‰²ç©ºé–“ï¼‰
        function rgbToLab(rgb) {
            // RGB to XYZ
            let r = rgb[0] / 255;
            let g = rgb[1] / 255;
            let b = rgb[2] / 255;

            // sRGBã‚¬ãƒ³ãƒè£œæ­£
            r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
            g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
            b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

            // RGB to XYZ
            let x = (r * 0.4124564 + g * 0.3575761 + b * 0.1804375) * 100;
            let y = (r * 0.2126729 + g * 0.7151522 + b * 0.0721750) * 100;
            let z = (r * 0.0193339 + g * 0.1191920 + b * 0.9503041) * 100;

            // XYZ to Lab (D65)
            x /= 95.047;
            y /= 100.000;
            z /= 108.883;

            x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16/116);
            y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16/116);
            z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16/116);

            return [
                (116 * y) - 16,  // L
                500 * (x - y),   // a
                200 * (y - z)    // b
            ];
        }

        // Labè‰²å·®ï¼ˆÎ”E CIE76ï¼‰
        function deltaE(lab1, lab2) {
            return Math.sqrt(
                Math.pow(lab1[0] - lab2[0], 2) +
                Math.pow(lab1[1] - lab2[1], 2) +
                Math.pow(lab1[2] - lab2[2], 2)
            );
        }

        // é…åˆè¨ˆç®—ï¼ˆAPIã¾ãŸã¯ãƒ­ãƒ¼ã‚«ãƒ«è¨ˆç®—ï¼‰
        async function calculateMix() {
            const hex = hexInput.value;
            const target = hexToRgb(hex);
            const targetRgb = [target.r, target.g, target.b];

            // ã¾ãšAPIã‚’è©¦ã™
            try {
                const response = await fetch('/api/mix', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ hex: hex })
                });

                if (response.ok) {
                    const data = await response.json();
                    displayResults(targetRgb, data.ratios);
                    console.log('API calculation used');
                    return;
                }
            } catch (e) {
                console.log('API not available, using local calculation');
            }

            // APIãŒä½¿ãˆãªã„å ´åˆã¯ãƒ­ãƒ¼ã‚«ãƒ«è¨ˆç®—
            calculateMixLocal(targetRgb);
        }

        // ç›®æ¨™è‰²ã«æœ€ã‚‚è¿‘ã„è‰²ã‚’è¦‹ã¤ã‘ã‚‹
        function findClosestColors(targetRgb, n) {
            const targetLab = rgbToLab(targetRgb);
            const distances = [];

            for (const [name, rgb] of Object.entries(BASE_COLORS)) {
                const colorLab = rgbToLab(rgb);
                const dist = deltaE(targetLab, colorLab);
                distances.push({ name, dist, rgb });
            }

            distances.sort((a, b) => a.dist - b.dist);
            return distances.slice(0, n);
        }

        // å€™è£œè‰²ã‚’é¸å®šï¼ˆãƒ™ãƒ¼ã‚¹è‰²åŸºæº–ï¼‰
        function selectCandidateColors(targetRgb, maxColors) {
            const targetLab = rgbToLab(targetRgb);
            const closest = findClosestColors(targetRgb, maxColors * 2);
            const baseColor = closest[0];

            // ãƒ™ãƒ¼ã‚¹è‰²ã ã‘ã§ååˆ†è¿‘ã„å ´åˆ
            if (baseColor.dist < 3.0) {
                return [baseColor.name];
            }

            const candidates = [baseColor.name];
            const baseRgb = BASE_COLORS[baseColor.name];
            const baseLab = rgbToLab(baseRgb);

            // å·®åˆ†ã‚’è¨ˆç®—
            const diffLab = [
                targetLab[0] - baseLab[0],
                targetLab[1] - baseLab[1],
                targetLab[2] - baseLab[2]
            ];

            // å·®åˆ†ã‚’è£œæ­£ã§ãã‚‹è‰²ã‚’ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°
            const colorScores = [];
            for (const item of closest.slice(1)) {
                const colorLab = rgbToLab(BASE_COLORS[item.name]);
                const directionLab = [
                    colorLab[0] - baseLab[0],
                    colorLab[1] - baseLab[1],
                    colorLab[2] - baseLab[2]
                ];

                // å†…ç©ã§æ–¹å‘ã®ä¸€è‡´åº¦ã‚’è©•ä¾¡
                const alignment = diffLab[0] * directionLab[0] +
                                  diffLab[1] * directionLab[1] +
                                  diffLab[2] * directionLab[2];

                const score = alignment / (item.dist + 1);
                colorScores.push({ name: item.name, score, dist: item.dist });
            }

            // ã‚¹ã‚³ã‚¢é †ã«ã‚½ãƒ¼ãƒˆ
            colorScores.sort((a, b) => b.score - a.score);

            // å€™è£œã‚’è¿½åŠ 
            for (const item of colorScores) {
                if (candidates.length >= maxColors) break;
                if (item.score > 0 || item.dist < 30) {
                    candidates.push(item.name);
                }
            }

            // å€™è£œãŒè¶³ã‚Šãªã„å ´åˆã€è¿‘ã„è‰²ã‚’è¿½åŠ 
            for (const item of closest) {
                if (candidates.length >= maxColors) break;
                if (!candidates.includes(item.name)) {
                    candidates.push(item.name);
                }
            }

            return candidates;
        }

        // é¸æŠã•ã‚ŒãŸè‰²ã§æœ€é©åŒ–
        function optimizeWithColors(targetRgb, selectedColors) {
            const colorMatrix = selectedColors.map(name => BASE_COLORS[name]);
            const targetLab = rgbToLab(targetRgb);
            const n = selectedColors.length;

            function calcError(ratios) {
                const blended = blendColors(ratios, colorMatrix);
                const clipped = blended.map(v => Math.max(0, Math.min(255, v)));
                return deltaE(rgbToLab(clipped), targetLab);
            }

            let bestRatios = selectedColors.map(() => 1 / n);
            let bestError = calcError(bestRatios);

            // è¤‡æ•°ã®åˆæœŸå€¤ã‹ã‚‰æœ€é©åŒ–
            const initialPoints = [];

            // ãƒ™ãƒ¼ã‚¹è‰²é‡è¦–ã®åˆæœŸå€¤
            for (const baseRatio of [0.7, 0.5, 0.3]) {
                const x0 = selectedColors.map(() => (1 - baseRatio) / (n - 1));
                x0[0] = baseRatio;
                initialPoints.push(x0);
            }

            // ä¸Šä½2è‰²é‡è¦–
            if (n >= 2) {
                const x0 = selectedColors.map(() => 0);
                x0[0] = 0.6;
                x0[1] = 0.4;
                initialPoints.push(x0);
            }

            // å‡ç­‰é…åˆ†
            initialPoints.push(selectedColors.map(() => 1 / n));

            // ãƒ©ãƒ³ãƒ€ãƒ ï¼ˆãƒ™ãƒ¼ã‚¹è‰²é‡è¦–ï¼‰
            for (let i = 0; i < 10; i++) {
                const x0 = selectedColors.map(() => Math.random());
                x0[0] *= 2;
                normalize(x0);
                initialPoints.push(x0);
            }

            for (const x0 of initialPoints) {
                let ratios = [...x0];
                normalize(ratios);

                // å‹¾é…é™ä¸‹
                let lr = 0.03;
                for (let iter = 0; iter < 400; iter++) {
                    const error = calcError(ratios);

                    if (error < bestError) {
                        bestError = error;
                        bestRatios = [...ratios];
                    }

                    if (iter % 80 === 0) lr *= 0.85;

                    for (let i = 0; i < ratios.length; i++) {
                        const delta = 0.001;
                        const ratiosPlus = [...ratios];
                        ratiosPlus[i] += delta;
                        normalize(ratiosPlus);
                        const gradient = (calcError(ratiosPlus) - error) / delta;
                        ratios[i] -= lr * gradient;
                        ratios[i] = Math.max(0, ratios[i]);
                    }
                    normalize(ratios);

                    if (error < 0.5) break;
                }
            }

            // çµæœã‚’æ•´å½¢ï¼ˆ1%æœªæº€ã¯é™¤å¤–ï¼‰
            const result = {};
            selectedColors.forEach((name, i) => {
                if (bestRatios[i] >= 0.01) {
                    result[name] = Math.round(bestRatios[i] * 1000) / 1000;
                }
            });

            // æ­£è¦åŒ–
            const total = Object.values(result).reduce((a, b) => a + b, 0);
            for (let key in result) {
                result[key] = Math.round((result[key] / total) * 1000) / 1000;
            }

            return { ratios: result, error: bestError };
        }

        // ãƒ­ãƒ¼ã‚«ãƒ«è¨ˆç®—ï¼ˆãƒ™ãƒ¼ã‚¹è‰²åŸºæº– + é©å¿œçš„è‰²æ•°èª¿æ•´ï¼‰
        function calculateMixLocal(targetRgb) {
            const targetLab = rgbToLab(targetRgb);
            const totalColors = Object.keys(BASE_COLORS).length;
            const DELTA_E_THRESHOLD = 5.0;

            let bestResult = null;
            let bestError = Infinity;

            // 6è‰²ã‹ã‚‰é–‹å§‹ã€2è‰²ãšã¤å¢—ã‚„ã™
            for (let maxColors = 6; maxColors <= totalColors; maxColors += 2) {
                const candidates = selectCandidateColors(targetRgb, maxColors);
                const result = optimizeWithColors(targetRgb, candidates);

                if (result.error < bestError) {
                    bestError = result.error;
                    bestResult = result.ratios;
                }

                // Î”E < 5 ãªã‚‰çµ‚äº†
                if (result.error < DELTA_E_THRESHOLD) {
                    break;
                }
            }

            // ã¾ã ã—ãã„å€¤ã‚’è¶…ãˆã¦ã„ã‚‹å ´åˆã€å…¨è‰²ã§è©¦ã™
            if (bestError >= DELTA_E_THRESHOLD) {
                const allColors = Object.keys(BASE_COLORS);
                const result = optimizeWithColors(targetRgb, allColors);

                if (result.error < bestError) {
                    bestError = result.error;
                    bestResult = result.ratios;
                }
            }

            displayResults(targetRgb, bestResult);
        }

        // RGBå¹³å‡ã«ã‚ˆã‚‹æ··è‰²è¨ˆç®—
        function blendColors(ratios, colorMatrix) {
            const result = [0, 0, 0];
            for (let i = 0; i < ratios.length; i++) {
                for (let j = 0; j < 3; j++) {
                    result[j] += ratios[i] * colorMatrix[i][j];
                }
            }
            return result;
        }

        // æ”¹å–„ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚’ç”Ÿæˆ
        function generateAdvice(targetRgb, resultRgb, deltaE) {
            if (deltaE < 5) return null;

            const advice = [];
            const diff = [
                targetRgb[0] - resultRgb[0],  // Rå·®åˆ†
                targetRgb[1] - resultRgb[1],  // Gå·®åˆ†
                targetRgb[2] - resultRgb[2]   // Bå·®åˆ†
            ];

            // æ˜ã‚‹ã•ã®å·®ï¼ˆç°¡æ˜“è¨ˆç®—ï¼‰
            const targetBrightness = (targetRgb[0] + targetRgb[1] + targetRgb[2]) / 3;
            const resultBrightness = (resultRgb[0] + resultRgb[1] + resultRgb[2]) / 3;
            const brightnessDiff = targetBrightness - resultBrightness;

            // å½©åº¦ã®æ¨å®šï¼ˆæœ€å¤§å€¤ã¨æœ€å°å€¤ã®å·®ï¼‰
            const targetSaturation = Math.max(...targetRgb) - Math.min(...targetRgb);
            const resultSaturation = Math.max(...resultRgb) - Math.min(...resultRgb);

            // æ˜ã‚‹ã•ã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹
            if (brightnessDiff > 30) {
                advice.push({
                    type: 'brightness',
                    message: 'ğŸ’¡ ã‚‚ã£ã¨æ˜ã‚‹ãã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™',
                    suggestion: 'Whiteï¼ˆãƒ›ãƒ¯ã‚¤ãƒˆï¼‰ã®æ¯”ç‡ã‚’å¢—ã‚„ã—ã¦ãã ã•ã„'
                });
            } else if (brightnessDiff < -30) {
                advice.push({
                    type: 'brightness',
                    message: 'ğŸŒ‘ ã‚‚ã£ã¨æš—ãã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™',
                    suggestion: 'Blackï¼ˆãƒ–ãƒ©ãƒƒã‚¯ï¼‰ã®æ¯”ç‡ã‚’å¢—ã‚„ã—ã¦ãã ã•ã„'
                });
            }

            // è‰²ç›¸ã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹
            if (diff[0] > 40) {
                advice.push({
                    type: 'hue',
                    message: 'ğŸ”´ èµ¤ã¿ãŒè¶³ã‚Šã¾ã›ã‚“',
                    suggestion: 'Red, Orange, Hot Pink ãªã©ã‚’è¿½åŠ æ¤œè¨'
                });
            } else if (diff[0] < -40) {
                advice.push({
                    type: 'hue',
                    message: 'ğŸ”´ èµ¤ã¿ãŒå¼·ã™ãã¾ã™',
                    suggestion: 'Redç³»ã®è‰²ã‚’æ¸›ã‚‰ã—ã€Blue ã‚„ Green ã‚’æ¤œè¨'
                });
            }

            if (diff[1] > 40) {
                advice.push({
                    type: 'hue',
                    message: 'ğŸŸ¢ ç·‘ã¿ãŒè¶³ã‚Šã¾ã›ã‚“',
                    suggestion: 'Green, Midnight Green ãªã©ã‚’è¿½åŠ æ¤œè¨'
                });
            } else if (diff[1] < -40) {
                advice.push({
                    type: 'hue',
                    message: 'ğŸŸ¢ ç·‘ã¿ãŒå¼·ã™ãã¾ã™',
                    suggestion: 'Greenç³»ã‚’æ¸›ã‚‰ã—ã€Red ã‚„ Purple ã‚’æ¤œè¨'
                });
            }

            if (diff[2] > 40) {
                advice.push({
                    type: 'hue',
                    message: 'ğŸ”µ é’ã¿ãŒè¶³ã‚Šã¾ã›ã‚“',
                    suggestion: 'Blue, Light Blue, Purple ãªã©ã‚’è¿½åŠ æ¤œè¨'
                });
            } else if (diff[2] < -40) {
                advice.push({
                    type: 'hue',
                    message: 'ğŸ”µ é’ã¿ãŒå¼·ã™ãã¾ã™',
                    suggestion: 'Blueç³»ã‚’æ¸›ã‚‰ã—ã€Yellow ã‚„ Orange ã‚’æ¤œè¨'
                });
            }

            // å½©åº¦ã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹
            if (targetSaturation - resultSaturation > 50) {
                advice.push({
                    type: 'saturation',
                    message: 'âœ¨ ã‚‚ã£ã¨é®®ã‚„ã‹ãªè‰²ãŒå¿…è¦ã§ã™',
                    suggestion: 'ç¾åœ¨ã®Angelusã‚«ãƒ©ãƒ¼ã§ã¯å†ç¾ãŒé›£ã—ã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ã‚ˆã‚Šé®®ã‚„ã‹ãªåŸè‰²ã«è¿‘ã„è‰²ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚'
                });
            }

            // å…¨ä½“çš„ãªã‚¢ãƒ‰ãƒã‚¤ã‚¹
            if (deltaE >= 15) {
                advice.push({
                    type: 'general',
                    message: 'âš ï¸ å¤§ããªè‰²å·®ãŒã‚ã‚Šã¾ã™',
                    suggestion: 'ç›®æ¨™è‰²ãŒAngelusã®è‰²åŸŸå¤–ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚è¿‘ã„è‰²ã§å¦¥å”ã™ã‚‹ã‹ã€åˆ¥ã®çµµã®å…·ãƒ–ãƒ©ãƒ³ãƒ‰ã¨ã®ä½µç”¨ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚'
                });
            } else if (deltaE >= 10) {
                advice.push({
                    type: 'general',
                    message: 'ğŸ“ ä¸­ç¨‹åº¦ã®è‰²å·®ãŒã‚ã‚Šã¾ã™',
                    suggestion: 'å¾®èª¿æ•´ã§æ”¹å–„ã§ãã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ä¸Šè¨˜ã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚’å‚è€ƒã«é…åˆã‚’æ‰‹å‹•èª¿æ•´ã—ã¦ã¿ã¦ãã ã•ã„ã€‚'
                });
            }

            return advice;
        }

        function colorDistance(c1, c2) {
            return Math.sqrt(
                Math.pow(c1[0] - c2[0], 2) +
                Math.pow(c1[1] - c2[1], 2) +
                Math.pow(c1[2] - c2[2], 2)
            );
        }

        function normalize(arr) {
            const sum = arr.reduce((a, b) => a + b, 0);
            if (sum > 0) {
                for (let i = 0; i < arr.length; i++) {
                    arr[i] /= sum;
                }
            }
        }

        // çµæœè¡¨ç¤º
        function displayResults(targetRgb, ratios) {
            // å†ç¾è‰²ã‚’è¨ˆç®—
            const colorNames = Object.keys(BASE_COLORS);
            const colorMatrix = colorNames.map(name => BASE_COLORS[name]);
            const ratioArray = colorNames.map(name => ratios[name] || 0);
            const resultRgb = blendColors(ratioArray, colorMatrix);
            const clippedRgb = resultRgb.map(v => Math.max(0, Math.min(255, v)));
            const resultHex = rgbToHex(
                Math.round(clippedRgb[0]),
                Math.round(clippedRgb[1]),
                Math.round(clippedRgb[2])
            );

            // Labè‰²å·®ï¼ˆÎ”Eï¼‰ã§èª¤å·®è¨ˆç®—
            const targetLab = rgbToLab(targetRgb);
            const resultLab = rgbToLab(clippedRgb);
            const de = deltaE(targetLab, resultLab);
            const errorPercent = Math.min(de, 100).toFixed(1);

            // å††ã‚°ãƒ©ãƒ•æ›´æ–°
            updateChart(ratios);

            // ãƒªã‚¹ãƒˆæ›´æ–°
            const ratioList = document.getElementById('ratioList');
            ratioList.innerHTML = '';

            const sortedRatios = Object.entries(ratios).sort((a, b) => b[1] - a[1]);
            for (const [name, value] of sortedRatios) {
                const percent = (value * 100).toFixed(1);
                const item = document.createElement('div');
                item.className = 'ratio-item';
                item.innerHTML = `
                    <div class="ratio-color" style="background: ${CHART_COLORS[name]};"></div>
                    <span class="ratio-name">${name} (${COLOR_NAMES_JP[name]})</span>
                    <span class="ratio-value">${percent}%</span>
                `;
                ratioList.appendChild(item);
            }

            // å†ç¾è‰²è¡¨ç¤º
            document.getElementById('resultSwatch').style.backgroundColor = resultHex;
            document.getElementById('resultHex').textContent = resultHex;

            // Î”Eè¡¨ç¤ºã¨ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è‰²
            const errorBadge = document.getElementById('errorBadge');
            errorBadge.textContent = `Î”E: ${errorPercent}`;
            if (de <= 5) {
                errorBadge.style.background = 'rgba(0, 200, 100, 0.2)';
                errorBadge.style.color = '#00C864';
            } else if (de <= 10) {
                errorBadge.style.background = 'rgba(255, 200, 0, 0.2)';
                errorBadge.style.color = '#FFC800';
            } else {
                errorBadge.style.background = 'rgba(233, 69, 96, 0.2)';
                errorBadge.style.color = '#ff6b6b';
            }

            // ã‚¢ãƒ‰ãƒã‚¤ã‚¹è¡¨ç¤º
            const adviceContainer = document.getElementById('adviceContainer');
            if (de >= 5) {
                const advice = generateAdvice(targetRgb, clippedRgb, de);
                if (advice && advice.length > 0) {
                    let adviceHtml = '<div class="advice-header">ğŸ’¡ æ”¹å–„ã‚¢ãƒ‰ãƒã‚¤ã‚¹</div>';
                    for (const item of advice) {
                        adviceHtml += `
                            <div class="advice-item advice-${item.type}">
                                <div class="advice-message">${item.message}</div>
                                <div class="advice-suggestion">${item.suggestion}</div>
                            </div>
                        `;
                    }
                    adviceContainer.innerHTML = adviceHtml;
                    adviceContainer.classList.remove('hidden');
                } else {
                    adviceContainer.classList.add('hidden');
                }
            } else {
                adviceContainer.innerHTML = '<div class="advice-success">âœ… è‰¯å¥½ãªé…åˆã§ã™ï¼Î”E < 5</div>';
                adviceContainer.classList.remove('hidden');
            }
        }

        // å††ã‚°ãƒ©ãƒ•æ›´æ–°
        function updateChart(ratios) {
            const labels = [];
            const data = [];
            const colors = [];
            const borderColors = [];

            for (const [name, value] of Object.entries(ratios)) {
                labels.push(COLOR_NAMES_JP[name]);
                data.push((value * 100).toFixed(1));
                colors.push(CHART_COLORS[name]);
                borderColors.push(name === '005-White' ? '#CCCCCC' : CHART_COLORS[name]);
            }

            if (ratioChart) {
                ratioChart.destroy();
            }

            ratioChart = new Chart(document.getElementById('ratioChart'), {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colors,
                        borderColor: borderColors,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                color: '#fff',
                                padding: 15,
                                font: {
                                    size: 12
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.label + ': ' + context.raw + '%';
                                }
                            }
                        }
                    }
                }
            });
        }

        // åˆæœŸè¨ˆç®—
        calculateMix();
    </script>
</body>
</html>
