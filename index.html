<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Angelus Paint Color Mixer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            background: linear-gradient(90deg, #e94560, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 30px;
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .image-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 20px;
            border: 2px dashed rgba(255, 255, 255, 0.2);
            transition: border-color 0.3s;
        }

        .image-section:hover {
            border-color: rgba(233, 69, 96, 0.5);
        }

        .image-section.dragover {
            border-color: #e94560;
            background: rgba(233, 69, 96, 0.1);
        }

        .drop-zone {
            min-height: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .drop-zone-text {
            text-align: center;
            color: #888;
        }

        .drop-zone-text h3 {
            margin-bottom: 10px;
            font-size: 1.3em;
        }

        .drop-zone-text p {
            font-size: 0.9em;
        }

        #imageCanvas {
            max-width: 100%;
            cursor: crosshair;
            border-radius: 8px;
            display: none;
        }

        .canvas-container {
            position: relative;
            overflow: hidden;
        }

        .zoom-controls {
            display: none;
            gap: 8px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .zoom-controls.visible {
            display: flex;
        }

        .zoom-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 8px 16px;
            color: #fff;
            cursor: pointer;
            font-size: 0.9em;
            transition: background 0.2s;
        }

        .zoom-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .zoom-info {
            color: #888;
            font-size: 0.85em;
            padding: 8px;
            display: flex;
            align-items: center;
        }

        .color-preview-float {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 3px solid white;
            border-radius: 50%;
            pointer-events: none;
            display: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transform: translate(-50%, -120%);
        }

        .results-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .card h3 {
            margin-bottom: 15px;
            font-size: 1.1em;
            color: #e94560;
        }

        .color-input-section {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .color-display {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .color-swatch {
            width: 80px;
            height: 80px;
            border-radius: 12px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .color-info {
            flex: 1;
        }

        .color-hex {
            font-size: 1.5em;
            font-weight: bold;
            font-family: monospace;
        }

        .color-rgb {
            color: #888;
            font-size: 0.9em;
            margin-top: 5px;
        }

        input[type="text"] {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 12px 16px;
            color: #fff;
            font-size: 1em;
            font-family: monospace;
            width: 140px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #e94560;
        }

        input[type="color"] {
            width: 50px;
            height: 46px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: transparent;
        }

        button {
            background: linear-gradient(135deg, #e94560, #ff6b6b);
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            color: white;
            font-size: 1em;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
        }

        .chart-container {
            position: relative;
            height: 250px;
            margin: 20px 0;
        }

        .ratio-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .ratio-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .ratio-color {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .ratio-name {
            flex: 1;
            font-size: 0.9em;
        }

        .ratio-value {
            font-weight: bold;
            font-family: monospace;
            color: #e94560;
        }

        .result-preview {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
        }

        .result-swatch {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .error-badge {
            display: inline-block;
            padding: 4px 12px;
            background: rgba(233, 69, 96, 0.2);
            border-radius: 20px;
            font-size: 0.85em;
            color: #ff6b6b;
        }

        .hidden {
            display: none !important;
        }

        .instructions {
            background: rgba(233, 69, 96, 0.1);
            border-left: 4px solid #e94560;
            padding: 15px;
            border-radius: 0 8px 8px 0;
            margin-bottom: 20px;
        }

        .instructions h4 {
            margin-bottom: 8px;
        }

        .instructions ul {
            margin-left: 20px;
            color: #aaa;
            font-size: 0.9em;
        }

        .instructions li {
            margin-bottom: 4px;
        }

        .reset-btn {
            background: rgba(255, 255, 255, 0.1);
            margin-top: 10px;
            width: 100%;
        }

        .reset-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            box-shadow: none;
        }

        /* „Ç¢„Éâ„Éê„Ç§„ÇπË°®Á§∫ */
        .advice-container {
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border-left: 4px solid #e94560;
        }

        .advice-container.hidden {
            display: none;
        }

        .advice-header {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 12px;
            color: #e94560;
        }

        .advice-item {
            margin-bottom: 12px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .advice-item:last-child {
            margin-bottom: 0;
        }

        .advice-message {
            font-weight: bold;
            margin-bottom: 4px;
        }

        .advice-suggestion {
            font-size: 0.9em;
            color: #aaa;
        }

        .advice-brightness .advice-message { color: #FFD700; }
        .advice-hue .advice-message { color: #87CEEB; }
        .advice-saturation .advice-message { color: #FF69B4; }
        .advice-general .advice-message { color: #FFA500; }

        .advice-success {
            color: #00C864;
            font-weight: bold;
            text-align: center;
            padding: 10px;
        }

        /* ‰ª£ÊõøËâ≤„ÅÆÊèêÊ°à */
        .alternative-color {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            margin-top: 8px;
        }

        .alt-color-swatch {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            flex-shrink: 0;
        }

        .alt-color-info {
            flex: 1;
            font-size: 0.95em;
        }

        .alt-color-info strong {
            font-size: 1.2em;
            font-family: monospace;
        }

        .alt-delta {
            color: #00C864;
            font-weight: bold;
        }

        .other-alternatives {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 8px;
        }

        .mini-alt {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            font-size: 0.85em;
            cursor: default;
        }

        .mini-alt:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .mini-swatch {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .advice-alternative .advice-message {
            color: #00C864;
        }

        .advice-alternatives .advice-message {
            color: #87CEEB;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Angelus Paint Color Mixer</h1>
        <p class="subtitle">AngelusÁµµ„ÅÆÂÖ∑„ÅÆÈÖçÂêàÊØîÁéá„ÇíËá™ÂãïË®àÁÆó</p>

        <div class="main-content">
            <div class="image-section" id="dropZone">
                <div class="drop-zone" id="dropZoneContent">
                    <div class="drop-zone-text">
                        <h3>ÁîªÂÉè„Çí„Éâ„É≠„ÉÉ„Éó„Åæ„Åü„ÅØ„Éö„Éº„Çπ„Éà</h3>
                        <p>„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû„Åô„Çã„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô</p>
                        <p style="margin-top: 15px; color: #666;">Ctrl+V „ÅßÁîªÂÉè„Çí„Éö„Éº„Çπ„ÉàÂèØËÉΩ</p>
                    </div>
                </div>
                <div class="canvas-container">
                    <canvas id="imageCanvas"></canvas>
                    <div class="color-preview-float" id="colorPreviewFloat"></div>
                </div>
                <div class="zoom-controls" id="zoomControls">
                    <button class="zoom-btn" id="zoomInBtn">+ Êã°Â§ß</button>
                    <button class="zoom-btn" id="zoomOutBtn">- Á∏ÆÂ∞è</button>
                    <button class="zoom-btn" id="zoomResetBtn">„É™„Çª„ÉÉ„Éà</button>
                    <span class="zoom-info" id="zoomInfo">100% | „Éõ„Ç§„Éº„É´„Åß„Ç∫„Éº„É†„ÄÅ„Éâ„É©„ÉÉ„Ç∞„ÅßÁßªÂãï</span>
                </div>
                <input type="file" id="fileInput" accept="image/*" style="display: none;">
                <button class="reset-btn hidden" id="resetBtn">Âà•„ÅÆÁîªÂÉè„ÇíÈÅ∏Êäû</button>
            </div>

            <div class="results-section">
                <div class="instructions">
                    <h4>‰Ωø„ÅÑÊñπ</h4>
                    <ul>
                        <li>ÁîªÂÉè„Çí„Éâ„É©„ÉÉ„Ç∞ÔºÜ„Éâ„É≠„ÉÉ„Éó„Åæ„Åü„ÅØ„Éö„Éº„Çπ„Éà</li>
                        <li>ÁîªÂÉè‰∏ä„Åß„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶Ëâ≤„ÇíÈÅ∏Êäû</li>
                        <li>„Åæ„Åü„ÅØ‰∏ã„ÅÆHEX„Ç≥„Éº„Éâ„ÇíÁõ¥Êé•ÂÖ•Âäõ</li>
                    </ul>
                </div>

                <div class="card">
                    <h3>„Çø„Éº„Ç≤„ÉÉ„ÉàËâ≤</h3>
                    <div class="color-input-section">
                        <input type="color" id="colorPicker" value="#FF8800">
                        <input type="text" id="hexInput" placeholder="#FF8800" value="#FF8800">
                        <button id="calculateBtn">Ë®àÁÆó</button>
                    </div>
                    <div class="color-display" style="margin-top: 15px;">
                        <div class="color-swatch" id="targetSwatch" style="background: #FF8800;"></div>
                        <div class="color-info">
                            <div class="color-hex" id="targetHex">#FF8800</div>
                            <div class="color-rgb" id="targetRgb">RGB(255, 136, 0)</div>
                        </div>
                    </div>
                </div>

                <div class="card" id="resultsCard">
                    <h3>ÈÖçÂêàÊØîÁéá</h3>
                    <div class="chart-container">
                        <canvas id="ratioChart"></canvas>
                    </div>
                    <div class="ratio-list" id="ratioList">
                        <!-- ÂãïÁöÑ„Å´ÁîüÊàê -->
                    </div>
                    <div class="result-preview">
                        <div class="result-swatch" id="resultSwatch"></div>
                        <div>
                            <div style="font-weight: bold;">ÂÜçÁèæËâ≤</div>
                            <div class="color-hex" id="resultHex" style="font-size: 1.2em;"></div>
                            <span class="error-badge" id="errorBadge"></span>
                            <div style="font-size: 0.75em; color: #666; margin-top: 4px;">
                                ŒîE‚â¶5: ÂÑ™ÁßÄ | ŒîE‚â¶10: ËâØÂ•Ω
                            </div>
                        </div>
                    </div>
                    <div class="advice-container hidden" id="adviceContainer">
                        <!-- „Ç¢„Éâ„Éê„Ç§„Çπ„ÅåÂãïÁöÑ„Å´Ë°®Á§∫„Åï„Çå„Çã -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // AngelusÂü∫Êú¨Ëâ≤ÔºàËª∏„Å®„Å™„Çã6Ëâ≤Ôºâ
        const PRIMARY_COLORS = {
            "001-Black": [20, 20, 25],
            "005-White": [255, 255, 255],
            "040-Blue": [0, 90, 170],
            "050-Green": [0, 130, 70],
            "064-Red": [200, 35, 40],
            "075-Yellow": [255, 210, 0]
        };

        // Ë£úÂä©Ëâ≤
        const SECONDARY_COLORS = {
            "024-Orange": [255, 100, 30],
            "047-Purple": [100, 50, 120],
            "014-Brown": [90, 55, 40],
            "029-Tan": [210, 170, 130],
            "041-Light Blue": [80, 160, 210],
            "052-Midnight Green": [0, 75, 70],
            "060-Burgundy": [120, 30, 50],
            "080-Dark Grey": [80, 80, 85],
            "082-Light Grey": [180, 180, 185],
            "188-Pink": [240, 150, 170],
            "186-Hot Pink": [255, 80, 140]
        };

        // ÂÖ®Ëâ≤„ÇíÁµêÂêà
        const BASE_COLORS = {...PRIMARY_COLORS, ...SECONDARY_COLORS};

        const COLOR_NAMES_JP = {
            "001-Black": "„Éñ„É©„ÉÉ„ÇØ",
            "005-White": "„Éõ„ÉØ„Ç§„Éà",
            "040-Blue": "„Éñ„É´„Éº",
            "050-Green": "„Ç∞„É™„Éº„É≥",
            "064-Red": "„É¨„ÉÉ„Éâ",
            "075-Yellow": "„Ç§„Ç®„É≠„Éº",
            "024-Orange": "„Ç™„É¨„É≥„Ç∏",
            "047-Purple": "„Éë„Éº„Éó„É´",
            "014-Brown": "„Éñ„É©„Ç¶„É≥",
            "029-Tan": "„Çø„É≥",
            "041-Light Blue": "„É©„Ç§„Éà„Éñ„É´„Éº",
            "052-Midnight Green": "„Éü„ÉÉ„Éâ„Éä„Ç§„Éà„Ç∞„É™„Éº„É≥",
            "060-Burgundy": "„Éê„Éº„Ç¨„É≥„Éá„Ç£",
            "080-Dark Grey": "„ÉÄ„Éº„ÇØ„Ç∞„É¨„Éº",
            "082-Light Grey": "„É©„Ç§„Éà„Ç∞„É¨„Éº",
            "188-Pink": "„Éî„É≥„ÇØ",
            "186-Hot Pink": "„Éõ„ÉÉ„Éà„Éî„É≥„ÇØ"
        };

        const CHART_COLORS = {
            "001-Black": "#141419",
            "005-White": "#EEEEEE",
            "040-Blue": "#005AAA",
            "050-Green": "#008246",
            "064-Red": "#C82328",
            "075-Yellow": "#FFD200",
            "024-Orange": "#FF641E",
            "047-Purple": "#643278",
            "014-Brown": "#5A3728",
            "029-Tan": "#D2AA82",
            "041-Light Blue": "#50A0D2",
            "052-Midnight Green": "#004B46",
            "060-Burgundy": "#781E32",
            "080-Dark Grey": "#505055",
            "082-Light Grey": "#B4B4B9",
            "188-Pink": "#F096AA",
            "186-Hot Pink": "#FF508C"
        };

        // DOMË¶ÅÁ¥†
        const dropZone = document.getElementById('dropZone');
        const dropZoneContent = document.getElementById('dropZoneContent');
        const fileInput = document.getElementById('fileInput');
        const canvas = document.getElementById('imageCanvas');
        const ctx = canvas.getContext('2d');
        const colorPreviewFloat = document.getElementById('colorPreviewFloat');
        const colorPicker = document.getElementById('colorPicker');
        const hexInput = document.getElementById('hexInput');
        const calculateBtn = document.getElementById('calculateBtn');
        const resetBtn = document.getElementById('resetBtn');
        const zoomControls = document.getElementById('zoomControls');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomResetBtn = document.getElementById('zoomResetBtn');
        const zoomInfo = document.getElementById('zoomInfo');

        let currentImage = null;
        let ratioChart = null;

        // „Ç∫„Éº„É†„Éª„Éë„É≥Áî®„ÅÆÁä∂ÊÖã
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let lastOffsetX = 0;
        let lastOffsetY = 0;

        // „Éâ„É©„ÉÉ„Ç∞&„Éâ„É≠„ÉÉ„Éó
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                loadImage(files[0]);
            }
        });

        // „ÇØ„É™„ÉÉ„ÇØ„Åß„Éï„Ç°„Ç§„É´ÈÅ∏Êäû
        dropZoneContent.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                loadImage(e.target.files[0]);
            }
        });

        // „Éö„Éº„Çπ„ÉàÂØæÂøú
        document.addEventListener('paste', (e) => {
            const items = e.clipboardData.items;
            for (let item of items) {
                if (item.type.indexOf('image') !== -1) {
                    const blob = item.getAsFile();
                    loadImage(blob);
                    break;
                }
            }
        });

        // ÁîªÂÉèË™≠„ÅøËæº„Åø
        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    currentImage = img;

                    // „Ç∫„Éº„É†Áä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
                    scale = 1;
                    offsetX = 0;
                    offsetY = 0;

                    // „Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫Ë™øÊï¥
                    const maxWidth = dropZone.clientWidth - 40;
                    const initialScale = Math.min(1, maxWidth / img.width);
                    canvas.width = img.width * initialScale;
                    canvas.height = img.height * initialScale;
                    canvas.dataset.initialScale = initialScale;

                    drawImage();

                    dropZoneContent.classList.add('hidden');
                    canvas.style.display = 'block';
                    zoomControls.classList.add('visible');
                    resetBtn.classList.remove('hidden');
                    updateZoomInfo();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // ÁîªÂÉèÊèèÁîªÔºà„Ç∫„Éº„É†„Éª„Éë„É≥ÂØæÂøúÔºâ
        function drawImage() {
            if (!currentImage) return;

            const initialScale = parseFloat(canvas.dataset.initialScale) || 1;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();

            // „Ç≠„É£„É≥„Éê„Çπ„ÅÆ‰∏≠ÂøÉ„ÇíÂü∫Ê∫ñ„Å´„Çπ„Ç±„Éº„É´
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            ctx.translate(centerX + offsetX, centerY + offsetY);
            ctx.scale(scale, scale);
            ctx.translate(-centerX, -centerY);

            ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
            ctx.restore();
        }

        // „Ç∫„Éº„É†ÊÉÖÂ†±Êõ¥Êñ∞
        function updateZoomInfo() {
            const percent = Math.round(scale * 100);
            zoomInfo.textContent = `${percent}% | „Éõ„Ç§„Éº„É´„Åß„Ç∫„Éº„É†„ÄÅ„Éâ„É©„ÉÉ„Ç∞„ÅßÁßªÂãï`;
        }

        // „Ç∫„Éº„É†„Ç§„É≥
        zoomInBtn.addEventListener('click', () => {
            scale = Math.min(scale * 1.25, 10);
            drawImage();
            updateZoomInfo();
        });

        // „Ç∫„Éº„É†„Ç¢„Ç¶„Éà
        zoomOutBtn.addEventListener('click', () => {
            scale = Math.max(scale / 1.25, 0.1);
            drawImage();
            updateZoomInfo();
        });

        // „Ç∫„Éº„É†„É™„Çª„ÉÉ„Éà
        zoomResetBtn.addEventListener('click', () => {
            scale = 1;
            offsetX = 0;
            offsetY = 0;
            drawImage();
            updateZoomInfo();
        });

        // „Éû„Ç¶„Çπ„Éõ„Ç§„Éº„É´„Åß„Ç∫„Éº„É†
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.max(0.1, Math.min(10, scale * delta));

            // „Éû„Ç¶„Çπ‰ΩçÁΩÆ„ÇíÂü∫Ê∫ñ„Å´„Ç∫„Éº„É†
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left - canvas.width / 2;
            const mouseY = e.clientY - rect.top - canvas.height / 2;

            offsetX = mouseX - (mouseX - offsetX) * (newScale / scale);
            offsetY = mouseY - (mouseY - offsetY) * (newScale / scale);

            scale = newScale;
            drawImage();
            updateZoomInfo();
        });

        // „Éâ„É©„ÉÉ„Ç∞„Åß„Éë„É≥
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 2 || e.shiftKey) { // Âè≥„ÇØ„É™„ÉÉ„ÇØ„Åæ„Åü„ÅØShift+„ÇØ„É™„ÉÉ„ÇØ„Åß„Éë„É≥
                isDragging = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                lastOffsetX = offsetX;
                lastOffsetY = offsetY;
                canvas.style.cursor = 'grabbing';
                e.preventDefault();
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                offsetX = lastOffsetX + (e.clientX - dragStartX);
                offsetY = lastOffsetY + (e.clientY - dragStartY);
                drawImage();
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                canvas.style.cursor = 'crosshair';
            }
        });

        // Âè≥„ÇØ„É™„ÉÉ„ÇØ„É°„Éã„É•„ÉºÁÑ°ÂäπÂåñ
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // „Ç≠„É£„É≥„Éê„Çπ„ÇØ„É™„ÉÉ„ÇØ„ÅßËâ≤ÂèñÂæó
        canvas.addEventListener('click', (e) => {
            if (isDragging) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // „Ç≠„É£„É≥„Éê„Çπ„ÅÆ„Éî„ÇØ„Çª„É´„Åã„ÇâÁõ¥Êé•Ëâ≤„ÇíÂèñÂæó
            const pixel = ctx.getImageData(x, y, 1, 1).data;

            // ÈÄèÊòéÈÉ®ÂàÜÔºàÁîªÂÉèÂ§ñÔºâ„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„ÅüÂ†¥Âêà„ÅØÁÑ°Ë¶ñ
            if (pixel[3] === 0) return;

            const hex = rgbToHex(pixel[0], pixel[1], pixel[2]);

            updateTargetColor(hex);
            calculateMix();
        });

        // „Éû„Ç¶„ÇπÁßªÂãï„Åß„Éó„É¨„Éì„É•„Éº
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const pixel = ctx.getImageData(x, y, 1, 1).data;

            // ÈÄèÊòéÈÉ®ÂàÜ„ÅØË°®Á§∫„Åó„Å™„ÅÑ
            if (pixel[3] === 0) {
                colorPreviewFloat.style.display = 'none';
                return;
            }

            const hex = rgbToHex(pixel[0], pixel[1], pixel[2]);

            colorPreviewFloat.style.display = 'block';
            colorPreviewFloat.style.left = x + 'px';
            colorPreviewFloat.style.top = y + 'px';
            colorPreviewFloat.style.backgroundColor = hex;
        });

        canvas.addEventListener('mouseleave', () => {
            colorPreviewFloat.style.display = 'none';
        });

        // „É™„Çª„ÉÉ„Éà
        resetBtn.addEventListener('click', () => {
            currentImage = null;
            scale = 1;
            offsetX = 0;
            offsetY = 0;
            canvas.style.display = 'none';
            zoomControls.classList.remove('visible');
            dropZoneContent.classList.remove('hidden');
            resetBtn.classList.add('hidden');
            fileInput.value = '';
        });

        // Ëâ≤ÂÖ•Âäõ
        colorPicker.addEventListener('input', (e) => {
            updateTargetColor(e.target.value);
        });

        colorPicker.addEventListener('change', () => {
            calculateMix();
        });

        hexInput.addEventListener('input', (e) => {
            let value = e.target.value;
            if (value.match(/^#?[0-9A-Fa-f]{6}$/)) {
                if (!value.startsWith('#')) value = '#' + value;
                updateTargetColor(value);
            }
        });

        hexInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                calculateMix();
            }
        });

        calculateBtn.addEventListener('click', calculateMix);

        // „Çø„Éº„Ç≤„ÉÉ„ÉàËâ≤Êõ¥Êñ∞
        function updateTargetColor(hex) {
            colorPicker.value = hex;
            hexInput.value = hex.toUpperCase();
            document.getElementById('targetSwatch').style.backgroundColor = hex;
            document.getElementById('targetHex').textContent = hex.toUpperCase();

            const rgb = hexToRgb(hex);
            document.getElementById('targetRgb').textContent = `RGB(${rgb.r}, ${rgb.g}, ${rgb.b})`;
        }

        // Ëâ≤Â§âÊèõ„É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£
        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('').toUpperCase();
        }

        function hexToRgb(hex) {
            hex = hex.replace('#', '');
            return {
                r: parseInt(hex.substr(0, 2), 16),
                g: parseInt(hex.substr(2, 2), 16),
                b: parseInt(hex.substr(4, 2), 16)
            };
        }

        // RGB to LabÂ§âÊèõÔºà‰∫∫Èñì„ÅÆÁü•Ë¶ö„Å´Ëøë„ÅÑËâ≤Á©∫ÈñìÔºâ
        function rgbToLab(rgb) {
            // RGB to XYZ
            let r = rgb[0] / 255;
            let g = rgb[1] / 255;
            let b = rgb[2] / 255;

            // sRGB„Ç¨„É≥„ÉûË£úÊ≠£
            r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
            g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
            b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

            // RGB to XYZ
            let x = (r * 0.4124564 + g * 0.3575761 + b * 0.1804375) * 100;
            let y = (r * 0.2126729 + g * 0.7151522 + b * 0.0721750) * 100;
            let z = (r * 0.0193339 + g * 0.1191920 + b * 0.9503041) * 100;

            // XYZ to Lab (D65)
            x /= 95.047;
            y /= 100.000;
            z /= 108.883;

            x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16/116);
            y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16/116);
            z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16/116);

            return [
                (116 * y) - 16,  // L
                500 * (x - y),   // a
                200 * (y - z)    // b
            ];
        }

        // LabËâ≤Â∑ÆÔºàŒîE CIE76Ôºâ
        function deltaE(lab1, lab2) {
            return Math.sqrt(
                Math.pow(lab1[0] - lab2[0], 2) +
                Math.pow(lab1[1] - lab2[1], 2) +
                Math.pow(lab1[2] - lab2[2], 2)
            );
        }

        // ÈÖçÂêàË®àÁÆóÔºàAPI„Åæ„Åü„ÅØ„É≠„Éº„Ç´„É´Ë®àÁÆóÔºâ
        async function calculateMix() {
            const hex = hexInput.value;
            const target = hexToRgb(hex);
            const targetRgb = [target.r, target.g, target.b];

            // „Åæ„ÅöAPI„ÇíË©¶„Åô
            try {
                const response = await fetch('/api/mix', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ hex: hex })
                });

                if (response.ok) {
                    const data = await response.json();
                    displayResults(targetRgb, data.ratios);
                    console.log('API calculation used');
                    return;
                }
            } catch (e) {
                console.log('API not available, using local calculation');
            }

            // API„Åå‰Ωø„Åà„Å™„ÅÑÂ†¥Âêà„ÅØ„É≠„Éº„Ç´„É´Ë®àÁÆó
            calculateMixLocal(targetRgb);
        }

        // ÁõÆÊ®ôËâ≤„Å´ÊúÄ„ÇÇËøë„ÅÑËâ≤„ÇíË¶ã„Å§„Åë„Çã
        function findClosestColors(targetRgb, n) {
            const targetLab = rgbToLab(targetRgb);
            const distances = [];

            for (const [name, rgb] of Object.entries(BASE_COLORS)) {
                const colorLab = rgbToLab(rgb);
                const dist = deltaE(targetLab, colorLab);
                distances.push({ name, dist, rgb });
            }

            distances.sort((a, b) => a.dist - b.dist);
            return distances.slice(0, n);
        }

        // ÂÄôË£úËâ≤„ÇíÈÅ∏ÂÆöÔºà„Éô„Éº„ÇπËâ≤Âü∫Ê∫ñÔºâ
        function selectCandidateColors(targetRgb, maxColors) {
            const targetLab = rgbToLab(targetRgb);
            const closest = findClosestColors(targetRgb, maxColors * 2);
            const baseColor = closest[0];

            // „Éô„Éº„ÇπËâ≤„Å†„Åë„ÅßÂçÅÂàÜËøë„ÅÑÂ†¥Âêà
            if (baseColor.dist < 3.0) {
                return [baseColor.name];
            }

            const candidates = [baseColor.name];
            const baseRgb = BASE_COLORS[baseColor.name];
            const baseLab = rgbToLab(baseRgb);

            // Â∑ÆÂàÜ„ÇíË®àÁÆó
            const diffLab = [
                targetLab[0] - baseLab[0],
                targetLab[1] - baseLab[1],
                targetLab[2] - baseLab[2]
            ];

            // Â∑ÆÂàÜ„ÇíË£úÊ≠£„Åß„Åç„ÇãËâ≤„Çí„Çπ„Ç≥„Ç¢„É™„É≥„Ç∞
            const colorScores = [];
            for (const item of closest.slice(1)) {
                const colorLab = rgbToLab(BASE_COLORS[item.name]);
                const directionLab = [
                    colorLab[0] - baseLab[0],
                    colorLab[1] - baseLab[1],
                    colorLab[2] - baseLab[2]
                ];

                // ÂÜÖÁ©ç„ÅßÊñπÂêë„ÅÆ‰∏ÄËá¥Â∫¶„ÇíË©ï‰æ°
                const alignment = diffLab[0] * directionLab[0] +
                                  diffLab[1] * directionLab[1] +
                                  diffLab[2] * directionLab[2];

                const score = alignment / (item.dist + 1);
                colorScores.push({ name: item.name, score, dist: item.dist });
            }

            // „Çπ„Ç≥„Ç¢È†Ü„Å´„ÇΩ„Éº„Éà
            colorScores.sort((a, b) => b.score - a.score);

            // ÂÄôË£ú„ÇíËøΩÂä†
            for (const item of colorScores) {
                if (candidates.length >= maxColors) break;
                if (item.score > 0 || item.dist < 30) {
                    candidates.push(item.name);
                }
            }

            // ÂÄôË£ú„ÅåË∂≥„Çä„Å™„ÅÑÂ†¥Âêà„ÄÅËøë„ÅÑËâ≤„ÇíËøΩÂä†
            for (const item of closest) {
                if (candidates.length >= maxColors) break;
                if (!candidates.includes(item.name)) {
                    candidates.push(item.name);
                }
            }

            return candidates;
        }

        // ÈÅ∏Êäû„Åï„Çå„ÅüËâ≤„ÅßÊúÄÈÅ©Âåñ
        function optimizeWithColors(targetRgb, selectedColors) {
            const colorMatrix = selectedColors.map(name => BASE_COLORS[name]);
            const targetLab = rgbToLab(targetRgb);
            const n = selectedColors.length;

            function calcError(ratios) {
                const blended = blendColors(ratios, colorMatrix);
                const clipped = blended.map(v => Math.max(0, Math.min(255, v)));
                return deltaE(rgbToLab(clipped), targetLab);
            }

            let bestRatios = selectedColors.map(() => 1 / n);
            let bestError = calcError(bestRatios);

            // Ë§áÊï∞„ÅÆÂàùÊúüÂÄ§„Åã„ÇâÊúÄÈÅ©Âåñ
            const initialPoints = [];

            // „Éô„Éº„ÇπËâ≤ÈáçË¶ñ„ÅÆÂàùÊúüÂÄ§
            for (const baseRatio of [0.7, 0.5, 0.3]) {
                const x0 = selectedColors.map(() => (1 - baseRatio) / (n - 1));
                x0[0] = baseRatio;
                initialPoints.push(x0);
            }

            // ‰∏ä‰Ωç2Ëâ≤ÈáçË¶ñ
            if (n >= 2) {
                const x0 = selectedColors.map(() => 0);
                x0[0] = 0.6;
                x0[1] = 0.4;
                initialPoints.push(x0);
            }

            // ÂùáÁ≠âÈÖçÂàÜ
            initialPoints.push(selectedColors.map(() => 1 / n));

            // „É©„É≥„ÉÄ„É†Ôºà„Éô„Éº„ÇπËâ≤ÈáçË¶ñÔºâ
            for (let i = 0; i < 10; i++) {
                const x0 = selectedColors.map(() => Math.random());
                x0[0] *= 2;
                normalize(x0);
                initialPoints.push(x0);
            }

            for (const x0 of initialPoints) {
                let ratios = [...x0];
                normalize(ratios);

                // ÂãæÈÖçÈôç‰∏ã
                let lr = 0.03;
                for (let iter = 0; iter < 400; iter++) {
                    const error = calcError(ratios);

                    if (error < bestError) {
                        bestError = error;
                        bestRatios = [...ratios];
                    }

                    if (iter % 80 === 0) lr *= 0.85;

                    for (let i = 0; i < ratios.length; i++) {
                        const delta = 0.001;
                        const ratiosPlus = [...ratios];
                        ratiosPlus[i] += delta;
                        normalize(ratiosPlus);
                        const gradient = (calcError(ratiosPlus) - error) / delta;
                        ratios[i] -= lr * gradient;
                        ratios[i] = Math.max(0, ratios[i]);
                    }
                    normalize(ratios);

                    if (error < 0.5) break;
                }
            }

            // ÁµêÊûú„ÇíÊï¥ÂΩ¢Ôºà1%Êú™Ê∫Ä„ÅØÈô§Â§ñÔºâ
            const result = {};
            selectedColors.forEach((name, i) => {
                if (bestRatios[i] >= 0.01) {
                    result[name] = Math.round(bestRatios[i] * 1000) / 1000;
                }
            });

            // Ê≠£Ë¶èÂåñ
            const total = Object.values(result).reduce((a, b) => a + b, 0);
            for (let key in result) {
                result[key] = Math.round((result[key] / total) * 1000) / 1000;
            }

            return { ratios: result, error: bestError };
        }

        // „É≠„Éº„Ç´„É´Ë®àÁÆóÔºà„Éô„Éº„ÇπËâ≤Âü∫Ê∫ñ + ÈÅ©ÂøúÁöÑËâ≤Êï∞Ë™øÊï¥Ôºâ
        function calculateMixLocal(targetRgb) {
            const targetLab = rgbToLab(targetRgb);
            const totalColors = Object.keys(BASE_COLORS).length;
            const DELTA_E_THRESHOLD = 5.0;

            let bestResult = null;
            let bestError = Infinity;

            // 6Ëâ≤„Åã„ÇâÈñãÂßã„ÄÅ2Ëâ≤„Åö„Å§Â¢ó„ÇÑ„Åô
            for (let maxColors = 6; maxColors <= totalColors; maxColors += 2) {
                const candidates = selectCandidateColors(targetRgb, maxColors);
                const result = optimizeWithColors(targetRgb, candidates);

                if (result.error < bestError) {
                    bestError = result.error;
                    bestResult = result.ratios;
                }

                // ŒîE < 5 „Å™„ÇâÁµÇ‰∫Ü
                if (result.error < DELTA_E_THRESHOLD) {
                    break;
                }
            }

            // „Åæ„Å†„Åó„Åç„ÅÑÂÄ§„ÇíË∂Ö„Åà„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÄÅÂÖ®Ëâ≤„ÅßË©¶„Åô
            if (bestError >= DELTA_E_THRESHOLD) {
                const allColors = Object.keys(BASE_COLORS);
                const result = optimizeWithColors(targetRgb, allColors);

                if (result.error < bestError) {
                    bestError = result.error;
                    bestResult = result.ratios;
                }
            }

            displayResults(targetRgb, bestResult);
        }

        // RGBÂπ≥Âùá„Å´„Çà„ÇãÊ∑∑Ëâ≤Ë®àÁÆó
        function blendColors(ratios, colorMatrix) {
            const result = [0, 0, 0];
            for (let i = 0; i < ratios.length; i++) {
                for (let j = 0; j < 3; j++) {
                    result[j] += ratios[i] * colorMatrix[i][j];
                }
            }
            return result;
        }

        // ‰ΩúÊàêÂèØËÉΩ„Å™Ëøë„ÅÑËâ≤„ÇíÊé¢„Åô
        function findAchievableColors(targetRgb) {
            const targetLab = rgbToLab(targetRgb);
            const achievable = [];

            // ÊñπÊ≥ï1: Êó¢Â≠ò„ÅÆÂçòËâ≤„ÅßËøë„ÅÑ„ÇÇ„ÅÆ„ÇíÊé¢„Åô
            for (const [name, rgb] of Object.entries(BASE_COLORS)) {
                const colorLab = rgbToLab(rgb);
                const de = deltaE(targetLab, colorLab);
                if (de < 20) {  // ÊØîËºÉÁöÑËøë„ÅÑËâ≤
                    achievable.push({
                        type: 'single',
                        name: name,
                        nameJp: COLOR_NAMES_JP[name],
                        rgb: rgb,
                        hex: rgbToHex(rgb[0], rgb[1], rgb[2]),
                        deltaE: de,
                        description: `${COLOR_NAMES_JP[name]}ÂçòËâ≤`
                    });
                }
            }

            // ÊñπÊ≥ï2: 2Ëâ≤„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ„ÅßËøë„ÅÑËâ≤„ÇíÊé¢„ÅôÔºà‰∏ªË¶Å„Å™ÁµÑ„ÅøÂêà„Çè„Åõ„ÅÆ„ÅøÔºâ
            const colorNames = Object.keys(BASE_COLORS);
            for (let i = 0; i < colorNames.length; i++) {
                for (let j = i + 1; j < colorNames.length; j++) {
                    // 50:50, 70:30, 30:70 „ÅÆÊØîÁéá„ÇíË©¶„Åô
                    for (const ratio of [0.5, 0.7, 0.3]) {
                        const rgb1 = BASE_COLORS[colorNames[i]];
                        const rgb2 = BASE_COLORS[colorNames[j]];
                        const mixed = [
                            rgb1[0] * ratio + rgb2[0] * (1 - ratio),
                            rgb1[1] * ratio + rgb2[1] * (1 - ratio),
                            rgb1[2] * ratio + rgb2[2] * (1 - ratio)
                        ];
                        const mixedLab = rgbToLab(mixed);
                        const de = deltaE(targetLab, mixedLab);

                        if (de < 5) {  // ŒîE < 5 „Åß‰Ωú„Çå„ÇãËâ≤
                            const r1 = Math.round(ratio * 100);
                            const r2 = 100 - r1;
                            achievable.push({
                                type: 'mix',
                                colors: [colorNames[i], colorNames[j]],
                                ratios: [ratio, 1 - ratio],
                                rgb: mixed,
                                hex: rgbToHex(Math.round(mixed[0]), Math.round(mixed[1]), Math.round(mixed[2])),
                                deltaE: de,
                                description: `${COLOR_NAMES_JP[colorNames[i]]} ${r1}% + ${COLOR_NAMES_JP[colorNames[j]]} ${r2}%`
                            });
                        }
                    }
                }
            }

            // ŒîEÈ†Ü„Å´„ÇΩ„Éº„Éà
            achievable.sort((a, b) => a.deltaE - b.deltaE);

            return achievable.slice(0, 5);  // ‰∏ä‰Ωç5‰ª∂
        }

        // ÊîπÂñÑ„Ç¢„Éâ„Éê„Ç§„Çπ„ÇíÁîüÊàê
        function generateAdvice(targetRgb, resultRgb, deltaE) {
            if (deltaE < 5) return null;

            const advice = [];

            // ‰ΩúÊàêÂèØËÉΩ„Å™Ëøë„ÅÑËâ≤„ÇíÊé¢„Åô
            const achievableColors = findAchievableColors(targetRgb);

            // ‰ª£ÊõøËâ≤„ÅÆÊèêÊ°à
            if (achievableColors.length > 0) {
                const bestAlt = achievableColors[0];

                if (bestAlt.deltaE < deltaE) {
                    let altHtml = `<div class="alternative-color">`;
                    altHtml += `<div class="alt-color-swatch" style="background: ${bestAlt.hex};"></div>`;
                    altHtml += `<div class="alt-color-info">`;
                    altHtml += `<strong>${bestAlt.hex}</strong><br>`;
                    altHtml += `${bestAlt.description}<br>`;
                    altHtml += `<span class="alt-delta">ŒîE: ${bestAlt.deltaE.toFixed(1)}</span>`;
                    altHtml += `</div></div>`;

                    advice.push({
                        type: 'alternative',
                        message: 'üé® „Åì„ÅÆËâ≤„Å™„Çâ‰Ωú„Çå„Åæ„ÅôÔºÅ',
                        suggestion: altHtml,
                        isHtml: true
                    });
                }

                // ‰ªñ„ÅÆÂÄôË£ú„ÇÇË°®Á§∫
                if (achievableColors.length > 1) {
                    let othersHtml = '<div class="other-alternatives">';
                    for (let i = 1; i < Math.min(4, achievableColors.length); i++) {
                        const alt = achievableColors[i];
                        othersHtml += `<div class="mini-alt" title="${alt.description} (ŒîE: ${alt.deltaE.toFixed(1)})">`;
                        othersHtml += `<div class="mini-swatch" style="background: ${alt.hex};"></div>`;
                        othersHtml += `<span>${alt.hex}</span>`;
                        othersHtml += `</div>`;
                    }
                    othersHtml += '</div>';

                    advice.push({
                        type: 'alternatives',
                        message: 'üìã ‰ªñ„ÅÆÂÄôË£ú',
                        suggestion: othersHtml,
                        isHtml: true
                    });
                }
            }

            // ÂÜçÁèæ„Åß„Åç„Å™„ÅÑÂ†¥Âêà„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏
            if (achievableColors.length === 0 || achievableColors[0].deltaE >= deltaE) {
                advice.push({
                    type: 'general',
                    message: '‚ö†Ô∏è ÁèæÂú®„ÅÆÈÖçÂêà„ÅåÊúÄÂñÑ„Åß„Åô',
                    suggestion: `ÁõÆÊ®ôËâ≤„Å´Ëøë„ÅÑ‰ª£ÊõøËâ≤„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇÁèæÂú®„ÅÆÈÖçÂêàÁµêÊûúÔºàŒîE: ${deltaE.toFixed(1)}Ôºâ„Çí„Åä‰Ωø„ÅÑ„Åè„Å†„Åï„ÅÑ„ÄÇ`
                });
            }

            return advice;
        }

        function colorDistance(c1, c2) {
            return Math.sqrt(
                Math.pow(c1[0] - c2[0], 2) +
                Math.pow(c1[1] - c2[1], 2) +
                Math.pow(c1[2] - c2[2], 2)
            );
        }

        function normalize(arr) {
            const sum = arr.reduce((a, b) => a + b, 0);
            if (sum > 0) {
                for (let i = 0; i < arr.length; i++) {
                    arr[i] /= sum;
                }
            }
        }

        // ÁµêÊûúË°®Á§∫
        function displayResults(targetRgb, ratios) {
            // ÂÜçÁèæËâ≤„ÇíË®àÁÆó
            const colorNames = Object.keys(BASE_COLORS);
            const colorMatrix = colorNames.map(name => BASE_COLORS[name]);
            const ratioArray = colorNames.map(name => ratios[name] || 0);
            const resultRgb = blendColors(ratioArray, colorMatrix);
            const clippedRgb = resultRgb.map(v => Math.max(0, Math.min(255, v)));
            const resultHex = rgbToHex(
                Math.round(clippedRgb[0]),
                Math.round(clippedRgb[1]),
                Math.round(clippedRgb[2])
            );

            // LabËâ≤Â∑ÆÔºàŒîEÔºâ„ÅßË™§Â∑ÆË®àÁÆó
            const targetLab = rgbToLab(targetRgb);
            const resultLab = rgbToLab(clippedRgb);
            const de = deltaE(targetLab, resultLab);
            const errorPercent = Math.min(de, 100).toFixed(1);

            // ÂÜÜ„Ç∞„É©„ÉïÊõ¥Êñ∞
            updateChart(ratios);

            // „É™„Çπ„ÉàÊõ¥Êñ∞
            const ratioList = document.getElementById('ratioList');
            ratioList.innerHTML = '';

            const sortedRatios = Object.entries(ratios).sort((a, b) => b[1] - a[1]);
            for (const [name, value] of sortedRatios) {
                const percent = (value * 100).toFixed(1);
                const item = document.createElement('div');
                item.className = 'ratio-item';
                item.innerHTML = `
                    <div class="ratio-color" style="background: ${CHART_COLORS[name]};"></div>
                    <span class="ratio-name">${name} (${COLOR_NAMES_JP[name]})</span>
                    <span class="ratio-value">${percent}%</span>
                `;
                ratioList.appendChild(item);
            }

            // ÂÜçÁèæËâ≤Ë°®Á§∫
            document.getElementById('resultSwatch').style.backgroundColor = resultHex;
            document.getElementById('resultHex').textContent = resultHex;

            // ŒîEË°®Á§∫„Å®„Çπ„ÉÜ„Éº„Çø„ÇπËâ≤
            const errorBadge = document.getElementById('errorBadge');
            errorBadge.textContent = `ŒîE: ${errorPercent}`;
            if (de <= 5) {
                errorBadge.style.background = 'rgba(0, 200, 100, 0.2)';
                errorBadge.style.color = '#00C864';
            } else if (de <= 10) {
                errorBadge.style.background = 'rgba(255, 200, 0, 0.2)';
                errorBadge.style.color = '#FFC800';
            } else {
                errorBadge.style.background = 'rgba(233, 69, 96, 0.2)';
                errorBadge.style.color = '#ff6b6b';
            }

            // „Ç¢„Éâ„Éê„Ç§„ÇπË°®Á§∫
            const adviceContainer = document.getElementById('adviceContainer');
            if (de >= 5) {
                const advice = generateAdvice(targetRgb, clippedRgb, de);
                if (advice && advice.length > 0) {
                    let adviceHtml = '<div class="advice-header">üí° ‰ª£ÊõøËâ≤„ÅÆÊèêÊ°à</div>';
                    for (const item of advice) {
                        if (item.isHtml) {
                            adviceHtml += `
                                <div class="advice-item advice-${item.type}">
                                    <div class="advice-message">${item.message}</div>
                                    <div class="advice-suggestion">${item.suggestion}</div>
                                </div>
                            `;
                        } else {
                            adviceHtml += `
                                <div class="advice-item advice-${item.type}">
                                    <div class="advice-message">${item.message}</div>
                                    <div class="advice-suggestion">${item.suggestion}</div>
                                </div>
                            `;
                        }
                    }
                    adviceContainer.innerHTML = adviceHtml;
                    adviceContainer.classList.remove('hidden');
                } else {
                    adviceContainer.classList.add('hidden');
                }
            } else {
                adviceContainer.innerHTML = '<div class="advice-success">‚úÖ ËâØÂ•Ω„Å™ÈÖçÂêà„Åß„ÅôÔºÅŒîE < 5</div>';
                adviceContainer.classList.remove('hidden');
            }
        }

        // ÂÜÜ„Ç∞„É©„ÉïÊõ¥Êñ∞
        function updateChart(ratios) {
            const labels = [];
            const data = [];
            const colors = [];
            const borderColors = [];

            for (const [name, value] of Object.entries(ratios)) {
                labels.push(COLOR_NAMES_JP[name]);
                data.push((value * 100).toFixed(1));
                colors.push(CHART_COLORS[name]);
                borderColors.push(name === '005-White' ? '#CCCCCC' : CHART_COLORS[name]);
            }

            if (ratioChart) {
                ratioChart.destroy();
            }

            ratioChart = new Chart(document.getElementById('ratioChart'), {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colors,
                        borderColor: borderColors,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                color: '#fff',
                                padding: 15,
                                font: {
                                    size: 12
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.label + ': ' + context.raw + '%';
                                }
                            }
                        }
                    }
                }
            });
        }

        // ÂàùÊúüË®àÁÆó
        calculateMix();
    </script>
</body>
</html>
