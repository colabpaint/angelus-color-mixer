<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Angelus Paint Color Mixer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            height: 100vh;
            overflow: hidden;
            color: #fff;
            position: relative;
        }

        /* Co-Lab Paint ç·æŸ„èƒŒæ™¯ */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.15;
            background-image: url("1.png");
            background-size: 600px auto;
            background-repeat: repeat;
            z-index: 0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            height: 100vh;
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
        }

        h1 {
            text-align: center;
            margin-bottom: 5px;
            font-size: 1.8em;
            background: linear-gradient(90deg, #e94560, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 15px;
            font-size: 0.9em;
        }


        .main-content {
            display: grid;
            grid-template-columns: 1fr 360px 320px;
            gap: 20px;
            flex: 1;
            min-height: 0;
        }

        @media (max-width: 1100px) {
            .main-content {
                grid-template-columns: 1fr 350px;
            }
            .alternatives-section {
                display: none;
            }
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .image-section {
            background: rgba(30, 35, 50, 0.85);
            border-radius: 12px;
            padding: 15px;
            border: 2px dashed rgba(233, 69, 96, 0.4);
            transition: border-color 0.3s, background 0.3s;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
            backdrop-filter: blur(8px);
        }

        .image-section:hover {
            border-color: rgba(233, 69, 96, 0.7);
            background: rgba(35, 40, 60, 0.9);
        }

        .image-section.dragover {
            border-color: #e94560;
            background: rgba(233, 69, 96, 0.15);
        }

        .drop-zone {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            min-height: 200px;
        }

        .drop-zone-text {
            text-align: center;
            color: #ccc;
            background: rgba(0, 0, 0, 0.3);
            padding: 30px 40px;
            border-radius: 12px;
        }

        .drop-zone-text h3 {
            margin-bottom: 10px;
            font-size: 1.3em;
            color: #fff;
        }

        .drop-zone-text p {
            font-size: 0.9em;
            color: #aaa;
        }

        #imageCanvas {
            max-width: 100%;
            cursor: crosshair;
            border-radius: 8px;
            display: none;
        }

        .canvas-container {
            position: relative;
            overflow: hidden;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #imageCanvas {
            max-height: 100%;
            object-fit: contain;
        }

        .zoom-controls {
            display: none;
            gap: 8px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .zoom-controls.visible {
            display: flex;
        }

        .zoom-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 8px 16px;
            color: #fff;
            cursor: pointer;
            font-size: 0.9em;
            transition: background 0.2s;
        }

        .zoom-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .zoom-info {
            color: #888;
            font-size: 0.85em;
            padding: 8px;
            display: flex;
            align-items: center;
        }

        .color-preview-float {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 3px solid white;
            border-radius: 50%;
            pointer-events: none;
            display: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transform: translate(-50%, -120%);
        }

        .results-section {
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 0;
            overflow-y: auto;
        }

        .alternatives-section {
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 0;
            overflow-y: auto;
        }

        .card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 15px;
            backdrop-filter: blur(10px);
            flex-shrink: 0;
        }

        .card.scrollable {
            flex: 1;
            min-height: 0;
            overflow-y: auto;
            flex-shrink: 1;
        }

        .card h3 {
            margin-bottom: 10px;
            font-size: 1em;
            color: #e94560;
        }

        .color-input-section {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .color-display {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .color-swatch {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .color-info {
            flex: 1;
        }

        .color-hex {
            font-size: 1.5em;
            font-weight: bold;
            font-family: monospace;
        }

        .color-rgb {
            color: #888;
            font-size: 0.9em;
            margin-top: 5px;
        }

        input[type="text"] {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 12px 16px;
            color: #fff;
            font-size: 1em;
            font-family: monospace;
            width: 140px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #e94560;
        }

        input[type="color"] {
            width: 50px;
            height: 46px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: transparent;
        }

        button {
            background: linear-gradient(135deg, #e94560, #ff6b6b);
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            color: white;
            font-size: 1em;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
        }

        .chart-container {
            position: relative;
            height: 180px;
            margin: 10px 0;
        }

        .ratio-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .ratio-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }

        .ratio-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .ratio-name {
            flex: 1;
            font-size: 0.8em;
        }

        .ratio-value {
            font-weight: bold;
            font-family: monospace;
            color: #e94560;
            font-size: 0.85em;
        }

        .result-preview {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .result-swatch {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .error-badge {
            display: inline-block;
            padding: 4px 12px;
            background: rgba(233, 69, 96, 0.2);
            border-radius: 20px;
            font-size: 0.85em;
            color: #ff6b6b;
        }

        .hidden {
            display: none !important;
        }

        .instructions {
            background: rgba(233, 69, 96, 0.1);
            border-left: 4px solid #e94560;
            padding: 10px 12px;
            border-radius: 0 8px 8px 0;
            font-size: 0.85em;
        }

        .instructions h4 {
            margin-bottom: 6px;
            font-size: 0.95em;
        }

        .instructions ul {
            margin-left: 18px;
            color: #aaa;
            font-size: 0.9em;
        }

        .instructions li {
            margin-bottom: 2px;
        }

        .reset-btn {
            background: rgba(255, 255, 255, 0.1);
            margin-top: 10px;
            width: 100%;
        }

        .reset-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            box-shadow: none;
        }

        /* ã‚¢ãƒ‰ãƒã‚¤ã‚¹è¡¨ç¤ºï¼ˆé…åˆçµæœã‚«ãƒ¼ãƒ‰å†…ç”¨ï¼‰ */
        .advice-container {
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid #e94560;
        }

        .advice-container.hidden {
            display: none;
        }

        .advice-header {
            font-weight: bold;
            font-size: 0.95em;
            margin-bottom: 8px;
            color: #e94560;
        }

        .advice-item {
            margin-bottom: 8px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }

        .advice-item:last-child {
            margin-bottom: 0;
        }

        .advice-message {
            font-weight: bold;
            margin-bottom: 3px;
            font-size: 0.9em;
        }

        .advice-suggestion {
            font-size: 0.85em;
            color: #aaa;
        }

        .advice-brightness .advice-message { color: #FFD700; }
        .advice-hue .advice-message { color: #87CEEB; }
        .advice-saturation .advice-message { color: #FF69B4; }
        .advice-general .advice-message { color: #FFA500; }

        .advice-success {
            color: #00C864;
            font-weight: bold;
            text-align: center;
            padding: 8px;
            font-size: 0.9em;
        }

        /* ä»£æ›¿è‰²ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆå³å´ãƒ‘ãƒãƒ«ï¼‰ */
        .alt-section-header {
            font-size: 1em;
            color: #e94560;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .alt-color-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: background 0.2s, transform 0.2s;
            border: 2px solid transparent;
        }

        .alt-color-card:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(3px);
        }

        .alt-color-card.best {
            border-color: #00C864;
        }

        .alt-color-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .alt-color-swatch {
            width: 45px;
            height: 45px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            flex-shrink: 0;
        }

        .alt-color-info {
            flex: 1;
        }

        .alt-color-hex {
            font-size: 1.1em;
            font-family: monospace;
            font-weight: bold;
        }

        .alt-color-delta {
            font-size: 0.85em;
            margin-top: 2px;
        }

        .alt-color-delta.good {
            color: #00C864;
        }

        .alt-color-delta.ok {
            color: #FFC800;
        }

        .alt-color-delta.poor {
            color: #ff6b6b;
        }

        .alt-color-desc {
            font-size: 0.8em;
            color: #aaa;
            line-height: 1.3;
        }

        .alt-empty-message {
            text-align: center;
            color: #666;
            padding: 20px;
            font-size: 0.9em;
        }

        /* æ—§ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆäº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰ */
        .alternative-color {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            margin-top: 6px;
        }

        .alt-delta {
            color: #00C864;
            font-weight: bold;
        }

        .other-alternatives {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 6px;
        }

        .mini-alt {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            font-size: 0.8em;
            cursor: pointer;
        }

        .mini-alt:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .mini-swatch {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .advice-alternative .advice-message {
            color: #00C864;
        }

        .advice-alternatives .advice-message {
            color: #87CEEB;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Angelus Paint Color Mixer</h1>
        <p class="subtitle">Angelusçµµã®å…·ã®é…åˆæ¯”ç‡ã‚’è‡ªå‹•è¨ˆç®—</p>

        <div class="main-content">
            <div class="image-section" id="dropZone">
                <div class="drop-zone" id="dropZoneContent">
                    <div class="drop-zone-text">
                        <div style="font-size: 3em; margin-bottom: 15px;">ğŸ“·</div>
                        <h3>ç”»åƒã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã¾ãŸã¯ãƒšãƒ¼ã‚¹ãƒˆ</h3>
                        <p>ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</p>
                        <p style="margin-top: 10px; font-size: 0.85em;">Ctrl+V ã§ãƒšãƒ¼ã‚¹ãƒˆå¯èƒ½</p>
                    </div>
                </div>
                <div class="canvas-container">
                    <canvas id="imageCanvas"></canvas>
                    <div class="color-preview-float" id="colorPreviewFloat"></div>
                </div>
                <div class="zoom-controls" id="zoomControls">
                    <button class="zoom-btn" id="zoomInBtn">+ æ‹¡å¤§</button>
                    <button class="zoom-btn" id="zoomOutBtn">- ç¸®å°</button>
                    <button class="zoom-btn" id="zoomResetBtn">ãƒªã‚»ãƒƒãƒˆ</button>
                    <span class="zoom-info" id="zoomInfo">100%</span>
                </div>
                <input type="file" id="fileInput" accept="image/*" style="display: none;">
                <button class="reset-btn hidden" id="resetBtn">åˆ¥ã®ç”»åƒã‚’é¸æŠ</button>
            </div>

            <div class="results-section">
                <div class="instructions">
                    <h4>ä½¿ã„æ–¹</h4>
                    <ul>
                        <li>ç”»åƒã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—</li>
                        <li>ç”»åƒä¸Šã§ã‚¯ãƒªãƒƒã‚¯ã—ã¦è‰²ã‚’é¸æŠ</li>
                        <li>ã¾ãŸã¯ä¸‹ã®HEXã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›</li>
                    </ul>
                </div>

                <div class="card">
                    <h3>ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè‰²</h3>
                    <div class="color-input-section">
                        <input type="color" id="colorPicker" value="#FF8800">
                        <input type="text" id="hexInput" placeholder="#FF8800" value="#FF8800">
                        <button id="calculateBtn">è¨ˆç®—</button>
                    </div>
                    <div class="color-display" style="margin-top: 10px;">
                        <div class="color-swatch" id="targetSwatch" style="background: #FF8800;"></div>
                        <div class="color-info">
                            <div class="color-hex" id="targetHex">#FF8800</div>
                            <div class="color-rgb" id="targetRgb">RGB(255, 136, 0)</div>
                        </div>
                    </div>
                </div>

                <div class="card scrollable" id="resultsCard">
                    <h3>é…åˆæ¯”ç‡</h3>
                    <div class="chart-container">
                        <canvas id="ratioChart"></canvas>
                    </div>
                    <div class="ratio-list" id="ratioList">
                        <!-- å‹•çš„ã«ç”Ÿæˆ -->
                    </div>
                    <div class="result-preview">
                        <div class="result-swatch" id="resultSwatch"></div>
                        <div>
                            <div style="font-weight: bold; font-size: 0.9em;">å†ç¾è‰²</div>
                            <div class="color-hex" id="resultHex" style="font-size: 1.1em;"></div>
                            <span class="error-badge" id="errorBadge"></span>
                        </div>
                    </div>
                    <div class="advice-container hidden" id="adviceContainer">
                        <!-- ã‚¢ãƒ‰ãƒã‚¤ã‚¹ãŒå‹•çš„ã«è¡¨ç¤ºã•ã‚Œã‚‹ -->
                    </div>
                </div>
            </div>

            <div class="alternatives-section">
                <div class="card scrollable">
                    <h3 class="alt-section-header">ä½œæˆå¯èƒ½ãªè¿‘ã„è‰²</h3>
                    <div id="alternativesList">
                        <!-- å‹•çš„ã«ç”Ÿæˆ -->
                        <div class="alt-empty-message">è‰²ã‚’é¸æŠã™ã‚‹ã¨å€™è£œãŒè¡¨ç¤ºã•ã‚Œã¾ã™</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // AngelusåŸºæœ¬è‰²ï¼ˆè»¸ã¨ãªã‚‹6è‰²ï¼‰
        const PRIMARY_COLORS = {
            "001-Black": [20, 20, 25],
            "005-White": [255, 255, 255],
            "040-Blue": [0, 90, 170],
            "050-Green": [0, 130, 70],
            "064-Red": [200, 35, 40],
            "075-Yellow": [255, 210, 0]
        };

        // è£œåŠ©è‰²
        const SECONDARY_COLORS = {
            "024-Orange": [255, 100, 30],
            "047-Purple": [100, 50, 120],
            "014-Brown": [90, 55, 40],
            "029-Tan": [210, 170, 130],
            "041-Light Blue": [80, 160, 210],
            "052-Midnight Green": [0, 75, 70],
            "060-Burgundy": [120, 30, 50],
            "080-Dark Grey": [80, 80, 85],
            "082-Light Grey": [180, 180, 185],
            "188-Pink": [240, 150, 170],
            "186-Hot Pink": [255, 80, 140]
        };

        // å…¨è‰²ã‚’çµåˆ
        const BASE_COLORS = {...PRIMARY_COLORS, ...SECONDARY_COLORS};

        const COLOR_NAMES_JP = {
            "001-Black": "ãƒ–ãƒ©ãƒƒã‚¯",
            "005-White": "ãƒ›ãƒ¯ã‚¤ãƒˆ",
            "040-Blue": "ãƒ–ãƒ«ãƒ¼",
            "050-Green": "ã‚°ãƒªãƒ¼ãƒ³",
            "064-Red": "ãƒ¬ãƒƒãƒ‰",
            "075-Yellow": "ã‚¤ã‚¨ãƒ­ãƒ¼",
            "024-Orange": "ã‚ªãƒ¬ãƒ³ã‚¸",
            "047-Purple": "ãƒ‘ãƒ¼ãƒ—ãƒ«",
            "014-Brown": "ãƒ–ãƒ©ã‚¦ãƒ³",
            "029-Tan": "ã‚¿ãƒ³",
            "041-Light Blue": "ãƒ©ã‚¤ãƒˆãƒ–ãƒ«ãƒ¼",
            "052-Midnight Green": "ãƒŸãƒƒãƒ‰ãƒŠã‚¤ãƒˆã‚°ãƒªãƒ¼ãƒ³",
            "060-Burgundy": "ãƒãƒ¼ã‚¬ãƒ³ãƒ‡ã‚£",
            "080-Dark Grey": "ãƒ€ãƒ¼ã‚¯ã‚°ãƒ¬ãƒ¼",
            "082-Light Grey": "ãƒ©ã‚¤ãƒˆã‚°ãƒ¬ãƒ¼",
            "188-Pink": "ãƒ”ãƒ³ã‚¯",
            "186-Hot Pink": "ãƒ›ãƒƒãƒˆãƒ”ãƒ³ã‚¯"
        };

        const CHART_COLORS = {
            "001-Black": "#141419",
            "005-White": "#EEEEEE",
            "040-Blue": "#005AAA",
            "050-Green": "#008246",
            "064-Red": "#C82328",
            "075-Yellow": "#FFD200",
            "024-Orange": "#FF641E",
            "047-Purple": "#643278",
            "014-Brown": "#5A3728",
            "029-Tan": "#D2AA82",
            "041-Light Blue": "#50A0D2",
            "052-Midnight Green": "#004B46",
            "060-Burgundy": "#781E32",
            "080-Dark Grey": "#505055",
            "082-Light Grey": "#B4B4B9",
            "188-Pink": "#F096AA",
            "186-Hot Pink": "#FF508C"
        };

        // DOMè¦ç´ 
        const dropZone = document.getElementById('dropZone');
        const dropZoneContent = document.getElementById('dropZoneContent');
        const fileInput = document.getElementById('fileInput');
        const canvas = document.getElementById('imageCanvas');
        const ctx = canvas.getContext('2d');
        const colorPreviewFloat = document.getElementById('colorPreviewFloat');
        const colorPicker = document.getElementById('colorPicker');
        const hexInput = document.getElementById('hexInput');
        const calculateBtn = document.getElementById('calculateBtn');
        const resetBtn = document.getElementById('resetBtn');
        const zoomControls = document.getElementById('zoomControls');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomResetBtn = document.getElementById('zoomResetBtn');
        const zoomInfo = document.getElementById('zoomInfo');

        let currentImage = null;
        let ratioChart = null;

        // ã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³ç”¨ã®çŠ¶æ…‹
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let lastOffsetX = 0;
        let lastOffsetY = 0;

        // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                loadImage(files[0]);
            }
        });

        // ã‚¯ãƒªãƒƒã‚¯ã§ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ
        dropZoneContent.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                loadImage(e.target.files[0]);
            }
        });

        // ãƒšãƒ¼ã‚¹ãƒˆå¯¾å¿œ
        document.addEventListener('paste', (e) => {
            const items = e.clipboardData.items;
            for (let item of items) {
                if (item.type.indexOf('image') !== -1) {
                    const blob = item.getAsFile();
                    loadImage(blob);
                    break;
                }
            }
        });

        // ç”»åƒèª­ã¿è¾¼ã¿
        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    currentImage = img;

                    // ã‚ºãƒ¼ãƒ çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                    scale = 1;
                    offsetX = 0;
                    offsetY = 0;

                    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºèª¿æ•´
                    const maxWidth = dropZone.clientWidth - 40;
                    const initialScale = Math.min(1, maxWidth / img.width);
                    canvas.width = img.width * initialScale;
                    canvas.height = img.height * initialScale;
                    canvas.dataset.initialScale = initialScale;

                    drawImage();

                    dropZoneContent.classList.add('hidden');
                    canvas.style.display = 'block';
                    zoomControls.classList.add('visible');
                    resetBtn.classList.remove('hidden');
                    updateZoomInfo();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // ç”»åƒæç”»ï¼ˆã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³å¯¾å¿œï¼‰
        function drawImage() {
            if (!currentImage) return;

            const initialScale = parseFloat(canvas.dataset.initialScale) || 1;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();

            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ä¸­å¿ƒã‚’åŸºæº–ã«ã‚¹ã‚±ãƒ¼ãƒ«
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            ctx.translate(centerX + offsetX, centerY + offsetY);
            ctx.scale(scale, scale);
            ctx.translate(-centerX, -centerY);

            ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
            ctx.restore();
        }

        // ã‚ºãƒ¼ãƒ æƒ…å ±æ›´æ–°
        function updateZoomInfo() {
            const percent = Math.round(scale * 100);
            zoomInfo.textContent = `${percent}%`;
        }

        // ã‚ºãƒ¼ãƒ ã‚¤ãƒ³
        zoomInBtn.addEventListener('click', () => {
            scale = Math.min(scale * 1.25, 10);
            drawImage();
            updateZoomInfo();
        });

        // ã‚ºãƒ¼ãƒ ã‚¢ã‚¦ãƒˆ
        zoomOutBtn.addEventListener('click', () => {
            scale = Math.max(scale / 1.25, 0.1);
            drawImage();
            updateZoomInfo();
        });

        // ã‚ºãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆ
        zoomResetBtn.addEventListener('click', () => {
            scale = 1;
            offsetX = 0;
            offsetY = 0;
            drawImage();
            updateZoomInfo();
        });

        // ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ 
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.max(0.1, Math.min(10, scale * delta));

            // ãƒã‚¦ã‚¹ä½ç½®ã‚’åŸºæº–ã«ã‚ºãƒ¼ãƒ 
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left - canvas.width / 2;
            const mouseY = e.clientY - rect.top - canvas.height / 2;

            offsetX = mouseX - (mouseX - offsetX) * (newScale / scale);
            offsetY = mouseY - (mouseY - offsetY) * (newScale / scale);

            scale = newScale;
            drawImage();
            updateZoomInfo();
        });

        // ãƒ‰ãƒ©ãƒƒã‚°ã§ãƒ‘ãƒ³
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 2 || e.shiftKey) { // å³ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯Shift+ã‚¯ãƒªãƒƒã‚¯ã§ãƒ‘ãƒ³
                isDragging = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                lastOffsetX = offsetX;
                lastOffsetY = offsetY;
                canvas.style.cursor = 'grabbing';
                e.preventDefault();
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                offsetX = lastOffsetX + (e.clientX - dragStartX);
                offsetY = lastOffsetY + (e.clientY - dragStartY);
                drawImage();
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                canvas.style.cursor = 'crosshair';
            }
        });

        // å³ã‚¯ãƒªãƒƒã‚¯ãƒ¡ãƒ‹ãƒ¥ãƒ¼ç„¡åŠ¹åŒ–
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¯ãƒªãƒƒã‚¯ã§è‰²å–å¾—
        canvas.addEventListener('click', (e) => {
            if (isDragging) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ãƒ”ã‚¯ã‚»ãƒ«ã‹ã‚‰ç›´æ¥è‰²ã‚’å–å¾—
            const pixel = ctx.getImageData(x, y, 1, 1).data;

            // é€æ˜éƒ¨åˆ†ï¼ˆç”»åƒå¤–ï¼‰ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã¯ç„¡è¦–
            if (pixel[3] === 0) return;

            const hex = rgbToHex(pixel[0], pixel[1], pixel[2]);

            updateTargetColor(hex);
            calculateMix();
        });

        // ãƒã‚¦ã‚¹ç§»å‹•ã§ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const pixel = ctx.getImageData(x, y, 1, 1).data;

            // é€æ˜éƒ¨åˆ†ã¯è¡¨ç¤ºã—ãªã„
            if (pixel[3] === 0) {
                colorPreviewFloat.style.display = 'none';
                return;
            }

            const hex = rgbToHex(pixel[0], pixel[1], pixel[2]);

            colorPreviewFloat.style.display = 'block';
            colorPreviewFloat.style.left = x + 'px';
            colorPreviewFloat.style.top = y + 'px';
            colorPreviewFloat.style.backgroundColor = hex;
        });

        canvas.addEventListener('mouseleave', () => {
            colorPreviewFloat.style.display = 'none';
        });

        // ãƒªã‚»ãƒƒãƒˆ
        resetBtn.addEventListener('click', () => {
            currentImage = null;
            scale = 1;
            offsetX = 0;
            offsetY = 0;
            canvas.style.display = 'none';
            zoomControls.classList.remove('visible');
            dropZoneContent.classList.remove('hidden');
            resetBtn.classList.add('hidden');
            fileInput.value = '';
        });

        // è‰²å…¥åŠ›
        colorPicker.addEventListener('input', (e) => {
            updateTargetColor(e.target.value);
        });

        colorPicker.addEventListener('change', () => {
            calculateMix();
        });

        hexInput.addEventListener('input', (e) => {
            let value = e.target.value;
            if (value.match(/^#?[0-9A-Fa-f]{6}$/)) {
                if (!value.startsWith('#')) value = '#' + value;
                updateTargetColor(value);
            }
        });

        hexInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                calculateMix();
            }
        });

        calculateBtn.addEventListener('click', calculateMix);

        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè‰²æ›´æ–°
        function updateTargetColor(hex) {
            colorPicker.value = hex;
            hexInput.value = hex.toUpperCase();
            document.getElementById('targetSwatch').style.backgroundColor = hex;
            document.getElementById('targetHex').textContent = hex.toUpperCase();

            const rgb = hexToRgb(hex);
            document.getElementById('targetRgb').textContent = `RGB(${rgb.r}, ${rgb.g}, ${rgb.b})`;
        }

        // è‰²å¤‰æ›ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('').toUpperCase();
        }

        function hexToRgb(hex) {
            hex = hex.replace('#', '');
            return {
                r: parseInt(hex.substr(0, 2), 16),
                g: parseInt(hex.substr(2, 2), 16),
                b: parseInt(hex.substr(4, 2), 16)
            };
        }

        // RGB to Labå¤‰æ›ï¼ˆäººé–“ã®çŸ¥è¦šã«è¿‘ã„è‰²ç©ºé–“ï¼‰
        function rgbToLab(rgb) {
            // RGB to XYZ
            let r = rgb[0] / 255;
            let g = rgb[1] / 255;
            let b = rgb[2] / 255;

            // sRGBã‚¬ãƒ³ãƒè£œæ­£
            r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
            g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
            b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

            // RGB to XYZ
            let x = (r * 0.4124564 + g * 0.3575761 + b * 0.1804375) * 100;
            let y = (r * 0.2126729 + g * 0.7151522 + b * 0.0721750) * 100;
            let z = (r * 0.0193339 + g * 0.1191920 + b * 0.9503041) * 100;

            // XYZ to Lab (D65)
            x /= 95.047;
            y /= 100.000;
            z /= 108.883;

            x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16/116);
            y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16/116);
            z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16/116);

            return [
                (116 * y) - 16,  // L
                500 * (x - y),   // a
                200 * (y - z)    // b
            ];
        }

        // Labè‰²å·®ï¼ˆÎ”E CIE76ï¼‰
        function deltaE(lab1, lab2) {
            return Math.sqrt(
                Math.pow(lab1[0] - lab2[0], 2) +
                Math.pow(lab1[1] - lab2[1], 2) +
                Math.pow(lab1[2] - lab2[2], 2)
            );
        }

        // é…åˆè¨ˆç®—ï¼ˆAPIã¾ãŸã¯ãƒ­ãƒ¼ã‚«ãƒ«è¨ˆç®—ï¼‰
        async function calculateMix() {
            const hex = hexInput.value;
            const target = hexToRgb(hex);
            const targetRgb = [target.r, target.g, target.b];

            // ã¾ãšAPIã‚’è©¦ã™
            try {
                const response = await fetch('/api/mix', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ hex: hex })
                });

                if (response.ok) {
                    const data = await response.json();
                    displayResults(targetRgb, data.ratios);
                    console.log('API calculation used');
                    return;
                }
            } catch (e) {
                console.log('API not available, using local calculation');
            }

            // APIãŒä½¿ãˆãªã„å ´åˆã¯ãƒ­ãƒ¼ã‚«ãƒ«è¨ˆç®—
            calculateMixLocal(targetRgb);
        }

        // ç›®æ¨™è‰²ã«æœ€ã‚‚è¿‘ã„è‰²ã‚’è¦‹ã¤ã‘ã‚‹
        function findClosestColors(targetRgb, n) {
            const targetLab = rgbToLab(targetRgb);
            const distances = [];

            for (const [name, rgb] of Object.entries(BASE_COLORS)) {
                const colorLab = rgbToLab(rgb);
                const dist = deltaE(targetLab, colorLab);
                distances.push({ name, dist, rgb });
            }

            distances.sort((a, b) => a.dist - b.dist);
            return distances.slice(0, n);
        }

        // å€™è£œè‰²ã‚’é¸å®šï¼ˆãƒ™ãƒ¼ã‚¹è‰²åŸºæº–ï¼‰
        function selectCandidateColors(targetRgb, maxColors) {
            const targetLab = rgbToLab(targetRgb);
            const closest = findClosestColors(targetRgb, maxColors * 2);
            const baseColor = closest[0];

            // ãƒ™ãƒ¼ã‚¹è‰²ã ã‘ã§ååˆ†è¿‘ã„å ´åˆ
            if (baseColor.dist < 3.0) {
                return [baseColor.name];
            }

            const candidates = [baseColor.name];
            const baseRgb = BASE_COLORS[baseColor.name];
            const baseLab = rgbToLab(baseRgb);

            // å·®åˆ†ã‚’è¨ˆç®—
            const diffLab = [
                targetLab[0] - baseLab[0],
                targetLab[1] - baseLab[1],
                targetLab[2] - baseLab[2]
            ];

            // å·®åˆ†ã‚’è£œæ­£ã§ãã‚‹è‰²ã‚’ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°
            const colorScores = [];
            for (const item of closest.slice(1)) {
                const colorLab = rgbToLab(BASE_COLORS[item.name]);
                const directionLab = [
                    colorLab[0] - baseLab[0],
                    colorLab[1] - baseLab[1],
                    colorLab[2] - baseLab[2]
                ];

                // å†…ç©ã§æ–¹å‘ã®ä¸€è‡´åº¦ã‚’è©•ä¾¡
                const alignment = diffLab[0] * directionLab[0] +
                                  diffLab[1] * directionLab[1] +
                                  diffLab[2] * directionLab[2];

                const score = alignment / (item.dist + 1);
                colorScores.push({ name: item.name, score, dist: item.dist });
            }

            // ã‚¹ã‚³ã‚¢é †ã«ã‚½ãƒ¼ãƒˆ
            colorScores.sort((a, b) => b.score - a.score);

            // å€™è£œã‚’è¿½åŠ 
            for (const item of colorScores) {
                if (candidates.length >= maxColors) break;
                if (item.score > 0 || item.dist < 30) {
                    candidates.push(item.name);
                }
            }

            // å€™è£œãŒè¶³ã‚Šãªã„å ´åˆã€è¿‘ã„è‰²ã‚’è¿½åŠ 
            for (const item of closest) {
                if (candidates.length >= maxColors) break;
                if (!candidates.includes(item.name)) {
                    candidates.push(item.name);
                }
            }

            return candidates;
        }

        // é¸æŠã•ã‚ŒãŸè‰²ã§æœ€é©åŒ–
        function optimizeWithColors(targetRgb, selectedColors) {
            const colorMatrix = selectedColors.map(name => BASE_COLORS[name]);
            const targetLab = rgbToLab(targetRgb);
            const n = selectedColors.length;

            function calcError(ratios) {
                const blended = blendColors(ratios, colorMatrix);
                const clipped = blended.map(v => Math.max(0, Math.min(255, v)));
                return deltaE(rgbToLab(clipped), targetLab);
            }

            let bestRatios = selectedColors.map(() => 1 / n);
            let bestError = calcError(bestRatios);

            // è¤‡æ•°ã®åˆæœŸå€¤ã‹ã‚‰æœ€é©åŒ–
            const initialPoints = [];

            // ãƒ™ãƒ¼ã‚¹è‰²é‡è¦–ã®åˆæœŸå€¤
            for (const baseRatio of [0.7, 0.5, 0.3]) {
                const x0 = selectedColors.map(() => (1 - baseRatio) / (n - 1));
                x0[0] = baseRatio;
                initialPoints.push(x0);
            }

            // ä¸Šä½2è‰²é‡è¦–
            if (n >= 2) {
                const x0 = selectedColors.map(() => 0);
                x0[0] = 0.6;
                x0[1] = 0.4;
                initialPoints.push(x0);
            }

            // å‡ç­‰é…åˆ†
            initialPoints.push(selectedColors.map(() => 1 / n));

            // ãƒ©ãƒ³ãƒ€ãƒ ï¼ˆãƒ™ãƒ¼ã‚¹è‰²é‡è¦–ï¼‰
            for (let i = 0; i < 10; i++) {
                const x0 = selectedColors.map(() => Math.random());
                x0[0] *= 2;
                normalize(x0);
                initialPoints.push(x0);
            }

            for (const x0 of initialPoints) {
                let ratios = [...x0];
                normalize(ratios);

                // å‹¾é…é™ä¸‹
                let lr = 0.03;
                for (let iter = 0; iter < 400; iter++) {
                    const error = calcError(ratios);

                    if (error < bestError) {
                        bestError = error;
                        bestRatios = [...ratios];
                    }

                    if (iter % 80 === 0) lr *= 0.85;

                    for (let i = 0; i < ratios.length; i++) {
                        const delta = 0.001;
                        const ratiosPlus = [...ratios];
                        ratiosPlus[i] += delta;
                        normalize(ratiosPlus);
                        const gradient = (calcError(ratiosPlus) - error) / delta;
                        ratios[i] -= lr * gradient;
                        ratios[i] = Math.max(0, ratios[i]);
                    }
                    normalize(ratios);

                    if (error < 0.5) break;
                }
            }

            // çµæœã‚’æ•´å½¢ï¼ˆ1%æœªæº€ã¯é™¤å¤–ï¼‰
            const result = {};
            selectedColors.forEach((name, i) => {
                if (bestRatios[i] >= 0.01) {
                    result[name] = Math.round(bestRatios[i] * 1000) / 1000;
                }
            });

            // æ­£è¦åŒ–
            const total = Object.values(result).reduce((a, b) => a + b, 0);
            for (let key in result) {
                result[key] = Math.round((result[key] / total) * 1000) / 1000;
            }

            return { ratios: result, error: bestError };
        }

        // ãƒ­ãƒ¼ã‚«ãƒ«è¨ˆç®—ï¼ˆãƒ™ãƒ¼ã‚¹è‰²åŸºæº– + é©å¿œçš„è‰²æ•°èª¿æ•´ï¼‰
        function calculateMixLocal(targetRgb) {
            const targetLab = rgbToLab(targetRgb);
            const totalColors = Object.keys(BASE_COLORS).length;
            const DELTA_E_THRESHOLD = 5.0;

            let bestResult = null;
            let bestError = Infinity;

            // 6è‰²ã‹ã‚‰é–‹å§‹ã€2è‰²ãšã¤å¢—ã‚„ã™
            for (let maxColors = 6; maxColors <= totalColors; maxColors += 2) {
                const candidates = selectCandidateColors(targetRgb, maxColors);
                const result = optimizeWithColors(targetRgb, candidates);

                if (result.error < bestError) {
                    bestError = result.error;
                    bestResult = result.ratios;
                }

                // Î”E < 5 ãªã‚‰çµ‚äº†
                if (result.error < DELTA_E_THRESHOLD) {
                    break;
                }
            }

            // ã¾ã ã—ãã„å€¤ã‚’è¶…ãˆã¦ã„ã‚‹å ´åˆã€å…¨è‰²ã§è©¦ã™
            if (bestError >= DELTA_E_THRESHOLD) {
                const allColors = Object.keys(BASE_COLORS);
                const result = optimizeWithColors(targetRgb, allColors);

                if (result.error < bestError) {
                    bestError = result.error;
                    bestResult = result.ratios;
                }
            }

            displayResults(targetRgb, bestResult);
        }

        // RGBå¹³å‡ã«ã‚ˆã‚‹æ··è‰²è¨ˆç®—
        function blendColors(ratios, colorMatrix) {
            const result = [0, 0, 0];
            for (let i = 0; i < ratios.length; i++) {
                for (let j = 0; j < 3; j++) {
                    result[j] += ratios[i] * colorMatrix[i][j];
                }
            }
            return result;
        }

        // ä½œæˆå¯èƒ½ãªè¿‘ã„è‰²ã‚’æ¢ã™ï¼ˆæ‹¡å¼µç‰ˆï¼‰
        function findAchievableColors(targetRgb) {
            const targetLab = rgbToLab(targetRgb);
            const achievable = [];
            const seen = new Set();  // é‡è¤‡é˜²æ­¢

            // æ–¹æ³•1: æ—¢å­˜ã®å˜è‰²ã§è¿‘ã„ã‚‚ã®ã‚’æ¢ã™
            for (const [name, rgb] of Object.entries(BASE_COLORS)) {
                const colorLab = rgbToLab(rgb);
                const de = deltaE(targetLab, colorLab);
                if (de < 30) {  // ã‚ˆã‚Šåºƒã„ç¯„å›²ã§æ¢ç´¢
                    const hex = rgbToHex(rgb[0], rgb[1], rgb[2]);
                    if (!seen.has(hex)) {
                        seen.add(hex);
                        achievable.push({
                            type: 'single',
                            name: name,
                            nameJp: COLOR_NAMES_JP[name],
                            rgb: rgb,
                            hex: hex,
                            deltaE: de,
                            description: `${COLOR_NAMES_JP[name]}å˜è‰²`
                        });
                    }
                }
            }

            // æ–¹æ³•2: 2è‰²ã®çµ„ã¿åˆã‚ã›ã§è¿‘ã„è‰²ã‚’æ¢ã™ï¼ˆã‚ˆã‚Šå¤šãã®æ¯”ç‡ã‚’è©¦ã™ï¼‰
            const colorNames = Object.keys(BASE_COLORS);
            const ratios = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9];

            for (let i = 0; i < colorNames.length; i++) {
                for (let j = i + 1; j < colorNames.length; j++) {
                    for (const ratio of ratios) {
                        const rgb1 = BASE_COLORS[colorNames[i]];
                        const rgb2 = BASE_COLORS[colorNames[j]];
                        const mixed = [
                            rgb1[0] * ratio + rgb2[0] * (1 - ratio),
                            rgb1[1] * ratio + rgb2[1] * (1 - ratio),
                            rgb1[2] * ratio + rgb2[2] * (1 - ratio)
                        ];
                        const mixedLab = rgbToLab(mixed);
                        const de = deltaE(targetLab, mixedLab);

                        if (de < 15) {  // Î”E < 15 ã¾ã§å€™è£œã«
                            const hex = rgbToHex(Math.round(mixed[0]), Math.round(mixed[1]), Math.round(mixed[2]));
                            if (!seen.has(hex)) {
                                seen.add(hex);
                                const r1 = Math.round(ratio * 100);
                                const r2 = 100 - r1;
                                achievable.push({
                                    type: 'mix',
                                    colors: [colorNames[i], colorNames[j]],
                                    ratios: [ratio, 1 - ratio],
                                    rgb: mixed,
                                    hex: hex,
                                    deltaE: de,
                                    description: `${COLOR_NAMES_JP[colorNames[i]]} ${r1}% + ${COLOR_NAMES_JP[colorNames[j]]} ${r2}%`
                                });
                            }
                        }
                    }
                }
            }

            // Î”Eé †ã«ã‚½ãƒ¼ãƒˆ
            achievable.sort((a, b) => a.deltaE - b.deltaE);

            return achievable.slice(0, 3);  // ä¸Šä½3ä»¶
        }

        // ä»£æ›¿è‰²ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’æ›´æ–°ï¼ˆå¸¸ã«è¡¨ç¤ºï¼‰
        function displayAlternatives(targetRgb, currentDeltaE) {
            const alternativesList = document.getElementById('alternativesList');
            const achievableColors = findAchievableColors(targetRgb);

            if (achievableColors.length === 0) {
                alternativesList.innerHTML = '<div class="alt-empty-message">è¿‘ã„è‰²ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ</div>';
                return;
            }

            let html = '';
            achievableColors.forEach((alt, index) => {
                const isBest = index === 0 && alt.deltaE < currentDeltaE;
                const deltaClass = alt.deltaE <= 5 ? 'good' : (alt.deltaE <= 10 ? 'ok' : 'poor');

                html += `<div class="alt-color-card ${isBest ? 'best' : ''}" data-hex="${alt.hex}" onclick="selectAlternative('${alt.hex}')">`;
                html += `<div class="alt-color-header">`;
                html += `<div class="alt-color-swatch" style="background: ${alt.hex};"></div>`;
                html += `<div class="alt-color-info">`;
                html += `<div class="alt-color-hex">${alt.hex}</div>`;
                html += `<div class="alt-color-delta ${deltaClass}">Î”E: ${alt.deltaE.toFixed(1)}${isBest ? ' â˜…æœ€é©' : ''}</div>`;
                html += `</div>`;
                html += `</div>`;
                html += `<div class="alt-color-desc">${alt.description}</div>`;
                html += `</div>`;
            });

            alternativesList.innerHTML = html;
        }

        // ä»£æ›¿è‰²ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã¨ãã®å‡¦ç†
        function selectAlternative(hex) {
            updateTargetColor(hex);
            calculateMix();
        }

        // æ”¹å–„ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚’ç”Ÿæˆï¼ˆç°¡ç•¥åŒ–ï¼‰
        function generateAdvice(targetRgb, resultRgb, currentDeltaE) {
            // å¸¸ã«ä»£æ›¿è‰²ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’æ›´æ–°
            displayAlternatives(targetRgb, currentDeltaE);

            // ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚³ãƒ³ãƒ†ãƒŠç”¨ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            if (currentDeltaE < 5) {
                return { type: 'success', message: 'è‰¯å¥½ãªé…åˆã§ã™' };
            } else if (currentDeltaE < 10) {
                return { type: 'ok', message: 'è¨±å®¹ç¯„å›²ã®é…åˆã§ã™' };
            } else {
                return { type: 'poor', message: 'å³å´ã®ä»£æ›¿è‰²ã‚’ãŠè©¦ã—ãã ã•ã„' };
            }
        }

        function colorDistance(c1, c2) {
            return Math.sqrt(
                Math.pow(c1[0] - c2[0], 2) +
                Math.pow(c1[1] - c2[1], 2) +
                Math.pow(c1[2] - c2[2], 2)
            );
        }

        function normalize(arr) {
            const sum = arr.reduce((a, b) => a + b, 0);
            if (sum > 0) {
                for (let i = 0; i < arr.length; i++) {
                    arr[i] /= sum;
                }
            }
        }

        // çµæœè¡¨ç¤º
        function displayResults(targetRgb, ratios) {
            // å†ç¾è‰²ã‚’è¨ˆç®—
            const colorNames = Object.keys(BASE_COLORS);
            const colorMatrix = colorNames.map(name => BASE_COLORS[name]);
            const ratioArray = colorNames.map(name => ratios[name] || 0);
            const resultRgb = blendColors(ratioArray, colorMatrix);
            const clippedRgb = resultRgb.map(v => Math.max(0, Math.min(255, v)));
            const resultHex = rgbToHex(
                Math.round(clippedRgb[0]),
                Math.round(clippedRgb[1]),
                Math.round(clippedRgb[2])
            );

            // Labè‰²å·®ï¼ˆÎ”Eï¼‰ã§èª¤å·®è¨ˆç®—
            const targetLab = rgbToLab(targetRgb);
            const resultLab = rgbToLab(clippedRgb);
            const de = deltaE(targetLab, resultLab);
            const errorPercent = Math.min(de, 100).toFixed(1);

            // å††ã‚°ãƒ©ãƒ•æ›´æ–°
            updateChart(ratios);

            // ãƒªã‚¹ãƒˆæ›´æ–°
            const ratioList = document.getElementById('ratioList');
            ratioList.innerHTML = '';

            const sortedRatios = Object.entries(ratios).sort((a, b) => b[1] - a[1]);
            for (const [name, value] of sortedRatios) {
                const percent = (value * 100).toFixed(1);
                const item = document.createElement('div');
                item.className = 'ratio-item';
                item.innerHTML = `
                    <div class="ratio-color" style="background: ${CHART_COLORS[name]};"></div>
                    <span class="ratio-name">${name} (${COLOR_NAMES_JP[name]})</span>
                    <span class="ratio-value">${percent}%</span>
                `;
                ratioList.appendChild(item);
            }

            // å†ç¾è‰²è¡¨ç¤º
            document.getElementById('resultSwatch').style.backgroundColor = resultHex;
            document.getElementById('resultHex').textContent = resultHex;

            // Î”Eè¡¨ç¤ºã¨ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è‰²
            const errorBadge = document.getElementById('errorBadge');
            errorBadge.textContent = `Î”E: ${errorPercent}`;
            if (de <= 5) {
                errorBadge.style.background = 'rgba(0, 200, 100, 0.2)';
                errorBadge.style.color = '#00C864';
            } else if (de <= 10) {
                errorBadge.style.background = 'rgba(255, 200, 0, 0.2)';
                errorBadge.style.color = '#FFC800';
            } else {
                errorBadge.style.background = 'rgba(233, 69, 96, 0.2)';
                errorBadge.style.color = '#ff6b6b';
            }

            // ã‚¢ãƒ‰ãƒã‚¤ã‚¹è¡¨ç¤ºï¼ˆå¸¸ã«ä»£æ›¿è‰²ã‚’æ›´æ–°ï¼‰
            const adviceContainer = document.getElementById('adviceContainer');
            const advice = generateAdvice(targetRgb, clippedRgb, de);

            if (advice.type === 'success') {
                adviceContainer.innerHTML = '<div class="advice-success">âœ… è‰¯å¥½ãªé…åˆã§ã™ï¼</div>';
            } else if (advice.type === 'ok') {
                adviceContainer.innerHTML = '<div class="advice-success" style="color: #FFC800;">âš ï¸ ' + advice.message + '</div>';
            } else {
                adviceContainer.innerHTML = '<div class="advice-success" style="color: #ff6b6b;">ğŸ’¡ ' + advice.message + '</div>';
            }
            adviceContainer.classList.remove('hidden');
        }

        // å††ã‚°ãƒ©ãƒ•æ›´æ–°
        function updateChart(ratios) {
            const labels = [];
            const data = [];
            const colors = [];
            const borderColors = [];

            for (const [name, value] of Object.entries(ratios)) {
                labels.push(COLOR_NAMES_JP[name]);
                data.push((value * 100).toFixed(1));
                colors.push(CHART_COLORS[name]);
                borderColors.push(name === '005-White' ? '#CCCCCC' : CHART_COLORS[name]);
            }

            if (ratioChart) {
                ratioChart.destroy();
            }

            ratioChart = new Chart(document.getElementById('ratioChart'), {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colors,
                        borderColor: borderColors,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                color: '#fff',
                                padding: 15,
                                font: {
                                    size: 12
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.label + ': ' + context.raw + '%';
                                }
                            }
                        }
                    }
                }
            });
        }

        // åˆæœŸè¨ˆç®—
        calculateMix();
    </script>
</body>
</html>
